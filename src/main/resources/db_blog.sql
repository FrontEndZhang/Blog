/*
Navicat MySQL Data Transfer

Source Server         : sincen
Source Server Version : 50719
Source Host           : localhost:3306
Source Database       : db_blog

Target Server Type    : MYSQL
Target Server Version : 50719
File Encoding         : 65001

Date: 2019-04-17 18:45:53
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `article_user_id` int(11) unsigned DEFAULT '1',
  `article_title` varchar(255) DEFAULT NULL,
  `markdown_content` mediumtext,
  `html_content` mediumtext,
  `article_view_count` int(11) DEFAULT '0',
  `article_comment_count` int(11) DEFAULT '0',
  `article_like_count` int(11) DEFAULT '0',
  `article_type` int(1) unsigned DEFAULT '1',
  `issue_type` int(11) unsigned DEFAULT '1',
  `article_update_time` datetime DEFAULT NULL,
  `article_create_time` datetime DEFAULT NULL,
  `article_image` varchar(200) DEFAULT '\\static\\pic\\default.jpg',
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=169 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('126', '1', '一周一部好电影IV【WEEK186 一级恐惧】', '# 2017-12-17 WEEK186 一级恐惧\r\n一级恐惧——————————————Primal Fear\r\n![](/Blog/static/pic/1554815529503.jpg)\r\n1. 导演：格里高利·霍布里特\r\n2. 主演：理查·基尔/劳拉·琳妮/约翰·马奥尼/阿尔法·伍达德/弗兰西斯·麦克多蒙德/爱德华·诺顿/特瑞·欧奎恩/安德鲁·布劳尔/斯蒂文·鲍尔/乔·斯帕诺/托尼·普拉纳/斯坦利·安德森/毛拉·蒂尔内/乔恩·塞达/瑞格·罗杰斯\r\n3. 片长：129 分钟\r\n4. 影 片类型：剧情/悬疑/惊悚/犯罪\r\n5. 豆 瓣评分：8.4/10(from88,522users)\r\n6. IMDB评分：7.7/10(from146,891users)\r\n\r\nHi，各位好久不见。本周给大家推荐的是一部96年的悬疑惊悚电影。你如果看过《搏击俱乐部》，一定不会忘记爱德华·诺顿饰演的杰克。而作为他的荧幕处女座，本片他虽然作为一个配角却已经技惊四座。当然主角的演技也不容忽视。可以说本片的一大亮点在于演员的精湛功力。\r\n\r\n歌颂完演技，来说说这部片子的实质。本片讨论的核心就在于正义。何为正义？通常我们觉得某个案子里，A是好人，B是坏人。那么B就应该受到惩罚，A就是应该伸张正义。然而很多时候，好人坏人的界定却很模糊。在某些情况下，A可能是好人，但是在某些情况下A就有可能是坏人。所以世间万事并不能简单的来下定义。正义正是如此。本片探讨的正义，在不同的情形下有不同的理解。而本片最让人觉得恐惧，并且赞叹的地方莫过于结局。那是来自内心的恐惧，那是Primal Fear。非常有意思的一部电影，值得一看。\r\n\r\n------------\r\n\r\n# 2017-11-26 WEEK183 嘉年华\r\n![](https://img.piegg.cn/week183.jpg?imageslim)\r\n1. 导演：文晏\r\n2. 主演：文淇/周美君/史可/耿乐/刘威葳/彭静/王栎鑫/李梦男\r\n3. 片长：107分钟\r\n4. 影 片类型：剧情\r\n5. 豆 瓣评分：8.6/10(from27,228users)\r\n6. IMDB评分：7.2/10(from195users)\r\n\r\nHi，各位好久不见。最近的一个月来，社会上发生了很多事，很多不是很好的事。不过这部电影能够过审，能够上映，却真的是一件最难得的事了。\r\n\r\n相信很多人都看过《熔炉》这部韩国电影，这部取材自真实事件，优秀的剧本+实力派的演员演绎的电影，自是获得无数赞誉，并且对韩国社会产生了意义深远的影响。而很多人把《嘉年华》这部电影比作中国版的《熔炉》，但我觉得这是不对的。不是说《熔炉》不好，《熔炉》这部好电影也是我以前推荐过的。我觉得更难得的是，我们拍出了《熔炉》这个级别的电影，而不是中国版的它——是难得的，是进步，伟大的一步。\r\n\r\n从剧情角度上来说，它可能不如《熔炉》“好看”。但我认为这部电影不是以“好看”“不好看”来鉴别的。它更多的是把这个社会对于幼童被性侵之后的种种态度，克制而坚决地表达了出来。它虽然是一部虚构的电影，但是它却时时刻刻能发生在我们的国家，我们的身边。\r\n\r\n片名的中文是《嘉年华》。但是英文名却很有意思的是《Angels Wear White》（天使穿着白衣）。与熔炉绝望的结局不同的是，《嘉年华》给出的结局，是开放的。有可能变得更好，也有可能一直糟糕下去，不过它带给我们的思考却是延续的，至少希望还是有的。我们在指责影片中那些令人发指的人物的行径的同时，可曾想过，如果事情发生在我们的身边，我们是否依然只是操起键盘一阵轰炸，茶余饭后一阵笑谈，三日之后相忘于江湖呢？我一直说，从电影中反观社会。《熔炉》之后改变了韩国，而《嘉年华》之后呢？看着那寥寥无几的排片，少得可怜的宣传，我曾想过的一些波澜，看来还是无法在我们的社会中惊起一些水花。\r\n\r\n我感动的是在观影中大家的安静，凝重和沉思。豆瓣上的一句话我看完，印象非常深刻但也非常痛心：“我们拍出了熔炉一样的电影，却没有熔炉一样的观众”。我希望这部电影应该是当下所有国人都应该观看的一部电影，因为，它真的是一部好电影。\r\n\r\n# 2017-11-12 WEEK182 非常嫌疑犯\r\n![](https://img.piegg.cn/week182.jpg?imageslim)\r\n1. 导演：布莱恩·辛格\r\n2. 主演：史蒂芬·鲍德温/加布里埃尔·伯恩/本尼西奥·德尔·托罗/凯文·波拉克/凯文·史派西/查兹·帕尔明特瑞/皮特·波斯尔思韦特/苏茜·爱米斯/吉安卡罗·埃斯波西托/丹·哈达亚/保罗·巴特尔/卡尔·布瑞斯勒/菲力浦·西蒙/杰克·希勒/克里斯汀·艾斯布鲁克\r\n3. 片长：106分钟\r\n4. 影 片类型：剧情/悬疑/惊悚/犯罪\r\n5. 豆 瓣评分：8.6/10(from113,108users)\r\n6. IMDB评分：8.6/10(from820,898users)\r\n\r\nHi，各位好久不见~本周给大家带来的是一部比较早期的电影——1995年的《非常嫌疑犯》。作为一部悬疑片，我觉得他的前几分钟的铺垫做的真的特别好。好的悬疑电影自然是在给观众想尽办法地留坑，然后再给你来一记重拳。不过明显的地方就是，你能感觉到留坑了，或者可能留坑了。\r\n\r\n这部电影则不一样，因为你是从一开始就被牵着鼻子走。而且得知真相的你还没来得及喘气之时，非常嫌疑犯已经扬长而去。不得不说凯文·史派西的演技在那个时候有已经是非常棒了。想感受一下被致命一击的恍然大悟，然后再由衷发出惊叹的话，这部电影不能错过。\r\n\r\n# 2017-11-09 WEEK181 暧暧内含光\r\n![](https://img.piegg.cn/week181.jpg?imageslim)\r\n\r\n1. 导演：米歇尔·贡德里\r\n2. 主演：金·凯瑞/凯特·温丝莱特/伊利亚·伍德/克斯汀·邓斯特/汤姆斯·杰·瑞恩/马克·鲁弗洛/简·亚当斯/大卫·克罗斯/汤姆·威尔金森/Amir Ali Said/Brian Price/Paulie Litt\r\n3. 片长：108分钟\r\n4. 影 片类型：剧情/爱情/奇幻\r\n5. 豆 瓣评分：8.4/10(from140,391users)\r\n6. IMDB评分：8.3/10(from741,540users)\r\n\r\nHi，各位好久不见~本周给大家推荐的是来自美国的一部很有意思的电影。关于记忆和爱情，它给出了别样的思考。\r\n\r\n这部电影可能一开始节奏有点慢有点怪。不过从一个时刻开始，这部电影就真的开始走向令人惊讶的地步了。情节猎奇，但是却一点也不狗血，相反很有内涵。我记得以前，曾听过一个我觉得很有感觉的说法。你可以抹去一个人的记忆，但是你却没有办法抹去对这个人的感觉。我觉得这句话用在这部电影里真的很合适。虽然是一部奇幻电影，但是带给我们的启迪却远超一部现实主义的电影。很多时候面对问题的时候我们很喜欢回避、逃避。但是很多时候直面问题反而能得到更好的效果。我们可以选择忘却一些东西，但是无法忘却曾经为此付出的时间和感情。\r\n\r\n也许你需要的不过是鼓起勇气说一声“对不起”，不过是一句“我错了”，不过是一句“我爱你”。但是选择了忘记，选择了逃避，你就选择了失去。好电影，值得一看。\r\n', '<h1 id=\"h1-2017-12-17-week186-\"><a name=\"2017-12-17 WEEK186 一级恐惧\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2017-12-17 WEEK186 一级恐惧</h1><p>一级恐惧——————————————Primal Fear<br><img src=\"/Blog/static/pic/1554815529503.jpg\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：格里高利·霍布里特</li><li>主演：理查·基尔/劳拉·琳妮/约翰·马奥尼/阿尔法·伍达德/弗兰西斯·麦克多蒙德/爱德华·诺顿/特瑞·欧奎恩/安德鲁·布劳尔/斯蒂文·鲍尔/乔·斯帕诺/托尼·普拉纳/斯坦利·安德森/毛拉·蒂尔内/乔恩·塞达/瑞格·罗杰斯</li><li>片长：129 分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.4/10(from88,522users)</li><li>IMDB评分：7.7/10(from146,891users)</li></ol>\r\n<p>Hi，各位好久不见。本周给大家推荐的是一部96年的悬疑惊悚电影。你如果看过《搏击俱乐部》，一定不会忘记爱德华·诺顿饰演的杰克。而作为他的荧幕处女座，本片他虽然作为一个配角却已经技惊四座。当然主角的演技也不容忽视。可以说本片的一大亮点在于演员的精湛功力。</p>\r\n<p>歌颂完演技，来说说这部片子的实质。本片讨论的核心就在于正义。何为正义？通常我们觉得某个案子里，A是好人，B是坏人。那么B就应该受到惩罚，A就是应该伸张正义。然而很多时候，好人坏人的界定却很模糊。在某些情况下，A可能是好人，但是在某些情况下A就有可能是坏人。所以世间万事并不能简单的来下定义。正义正是如此。本片探讨的正义，在不同的情形下有不同的理解。而本片最让人觉得恐惧，并且赞叹的地方莫过于结局。那是来自内心的恐惧，那是Primal Fear。非常有意思的一部电影，值得一看。</p>\r\n<hr>\r\n<h1 id=\"h1-2017-11-26-week183-\"><a name=\"2017-11-26 WEEK183 嘉年华\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2017-11-26 WEEK183 嘉年华</h1><p><img src=\"https://img.piegg.cn/week183.jpg?imageslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：文晏</li><li>主演：文淇/周美君/史可/耿乐/刘威葳/彭静/王栎鑫/李梦男</li><li>片长：107分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：8.6/10(from27,228users)</li><li>IMDB评分：7.2/10(from195users)</li></ol>\r\n<p>Hi，各位好久不见。最近的一个月来，社会上发生了很多事，很多不是很好的事。不过这部电影能够过审，能够上映，却真的是一件最难得的事了。</p>\r\n<p>相信很多人都看过《熔炉》这部韩国电影，这部取材自真实事件，优秀的剧本+实力派的演员演绎的电影，自是获得无数赞誉，并且对韩国社会产生了意义深远的影响。而很多人把《嘉年华》这部电影比作中国版的《熔炉》，但我觉得这是不对的。不是说《熔炉》不好，《熔炉》这部好电影也是我以前推荐过的。我觉得更难得的是，我们拍出了《熔炉》这个级别的电影，而不是中国版的它——是难得的，是进步，伟大的一步。</p>\r\n<p>从剧情角度上来说，它可能不如《熔炉》“好看”。但我认为这部电影不是以“好看”“不好看”来鉴别的。它更多的是把这个社会对于幼童被性侵之后的种种态度，克制而坚决地表达了出来。它虽然是一部虚构的电影，但是它却时时刻刻能发生在我们的国家，我们的身边。</p>\r\n<p>片名的中文是《嘉年华》。但是英文名却很有意思的是《Angels Wear White》（天使穿着白衣）。与熔炉绝望的结局不同的是，《嘉年华》给出的结局，是开放的。有可能变得更好，也有可能一直糟糕下去，不过它带给我们的思考却是延续的，至少希望还是有的。我们在指责影片中那些令人发指的人物的行径的同时，可曾想过，如果事情发生在我们的身边，我们是否依然只是操起键盘一阵轰炸，茶余饭后一阵笑谈，三日之后相忘于江湖呢？我一直说，从电影中反观社会。《熔炉》之后改变了韩国，而《嘉年华》之后呢？看着那寥寥无几的排片，少得可怜的宣传，我曾想过的一些波澜，看来还是无法在我们的社会中惊起一些水花。</p>\r\n<p>我感动的是在观影中大家的安静，凝重和沉思。豆瓣上的一句话我看完，印象非常深刻但也非常痛心：“我们拍出了熔炉一样的电影，却没有熔炉一样的观众”。我希望这部电影应该是当下所有国人都应该观看的一部电影，因为，它真的是一部好电影。</p>\r\n<h1 id=\"h1-2017-11-12-week182-\"><a name=\"2017-11-12 WEEK182 非常嫌疑犯\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2017-11-12 WEEK182 非常嫌疑犯</h1><p><img src=\"https://img.piegg.cn/week182.jpg?imageslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：布莱恩·辛格</li><li>主演：史蒂芬·鲍德温/加布里埃尔·伯恩/本尼西奥·德尔·托罗/凯文·波拉克/凯文·史派西/查兹·帕尔明特瑞/皮特·波斯尔思韦特/苏茜·爱米斯/吉安卡罗·埃斯波西托/丹·哈达亚/保罗·巴特尔/卡尔·布瑞斯勒/菲力浦·西蒙/杰克·希勒/克里斯汀·艾斯布鲁克</li><li>片长：106分钟</li><li>影 片类型：剧情/悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.6/10(from113,108users)</li><li>IMDB评分：8.6/10(from820,898users)</li></ol>\r\n<p>Hi，各位好久不见~本周给大家带来的是一部比较早期的电影——1995年的《非常嫌疑犯》。作为一部悬疑片，我觉得他的前几分钟的铺垫做的真的特别好。好的悬疑电影自然是在给观众想尽办法地留坑，然后再给你来一记重拳。不过明显的地方就是，你能感觉到留坑了，或者可能留坑了。</p>\r\n<p>这部电影则不一样，因为你是从一开始就被牵着鼻子走。而且得知真相的你还没来得及喘气之时，非常嫌疑犯已经扬长而去。不得不说凯文·史派西的演技在那个时候有已经是非常棒了。想感受一下被致命一击的恍然大悟，然后再由衷发出惊叹的话，这部电影不能错过。</p>\r\n<h1 id=\"h1-2017-11-09-week181-\"><a name=\"2017-11-09 WEEK181 暧暧内含光\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2017-11-09 WEEK181 暧暧内含光</h1><p><img src=\"https://img.piegg.cn/week181.jpg?imageslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：米歇尔·贡德里</li><li>主演：金·凯瑞/凯特·温丝莱特/伊利亚·伍德/克斯汀·邓斯特/汤姆斯·杰·瑞恩/马克·鲁弗洛/简·亚当斯/大卫·克罗斯/汤姆·威尔金森/Amir Ali Said/Brian Price/Paulie Litt</li><li>片长：108分钟</li><li>影 片类型：剧情/爱情/奇幻</li><li>豆 瓣评分：8.4/10(from140,391users)</li><li>IMDB评分：8.3/10(from741,540users)</li></ol>\r\n<p>Hi，各位好久不见~本周给大家推荐的是来自美国的一部很有意思的电影。关于记忆和爱情，它给出了别样的思考。</p>\r\n<p>这部电影可能一开始节奏有点慢有点怪。不过从一个时刻开始，这部电影就真的开始走向令人惊讶的地步了。情节猎奇，但是却一点也不狗血，相反很有内涵。我记得以前，曾听过一个我觉得很有感觉的说法。你可以抹去一个人的记忆，但是你却没有办法抹去对这个人的感觉。我觉得这句话用在这部电影里真的很合适。虽然是一部奇幻电影，但是带给我们的启迪却远超一部现实主义的电影。很多时候面对问题的时候我们很喜欢回避、逃避。但是很多时候直面问题反而能得到更好的效果。我们可以选择忘却一些东西，但是无法忘却曾经为此付出的时间和感情。</p>\r\n<p>也许你需要的不过是鼓起勇气说一声“对不起”，不过是一句“我错了”，不过是一句“我爱你”。但是选择了忘记，选择了逃避，你就选择了失去。好电影，值得一看。</p>\r\n', '78', '0', '0', '1', '1', '2019-04-09 21:12:12', '2019-04-05 21:53:39', '\\static\\bgpic\\1554472418701.jpg');
INSERT INTO `article` VALUES ('130', '1', 'Electron-vue开发实战6——开发插件系统之GUI部分', '# 前言\r\n###前台预告\r\n前段时间，我用electron-vue开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。预计将会从几篇系列文章或方面来展开：\r\n1. electron-vue入门\r\n2. Main进程和Renderer进程的简单开发\r\n3. 引入基于Lodash的JSON database——lowdb\r\n4. 跨平台的一些兼容措施\r\n5. 通过CI发布以及更新的方式\r\n6. 开发插件系统——CLI部分\r\n7. 开发插件系统——GUI部分\r\n8. 想到再写…\r\n\r\n# 说明\r\nPicGo是采用electron-vue开发的，所以如果你会vue，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如react、angular，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(Electron的主进程）应该还是能学习到相应的知识的。\r\n\r\n如果之前的文章没阅读的朋友可以先从之前的文章跟着看。并且如果没有看过前一篇CLI插件系统构建的朋友，需要先行阅读，本文涉及到的部分内容来自上一篇文章。\r\n# 运行时的require\r\n我们之前构建的插件系统是基于Node.js端的。对于Electron而言，main进程可以认为拥有Node.js环境，所以我们首先要在main进程里将其引入。而对于PicGo而言，由于上传流程已经完全抽离到PicGo-Core这个库里了，所以原本存在于Electron端的上传部分就可以精简整合成调用PicGo-Core的api来实现上传部分的逻辑了。\r\n\r\n而在引入PicGo-Core的时候会遇到一个问题。在Electron端，由于我使用的脚手架是Electron-vue，它会将main进程和renderer进程都通过Webapck进行打包。由于PicGo-Core用于加载插件的部分使用的是require，在Node.js端很正常没问题。但是Webpack并不知道这些require是在运行时才需要调用的，它会认为这是构建时的「常规」require，也就会在打包的时候把你require的插件也打包进来。这样明显是不合理的，我们是运行时才require插件的，所以需要做一些手段来「绕开」Webpack的打包机制：\r\n ``   const requireFunc = true ? require : require\r\n    const PicGo = requireFunc(\'picgo\')\r\n	``\r\n这样就可以避免PicGo-Core内部的require被Webpack也打包进去了。\r\n\r\n# 「前后端」分离\r\nElectron的main进程和renderer进程实际上你可以把它们看成我们平时Web开发的后端和前端。二者交流的工具也不再是Ajax，而是ipcMain和ipcRenderer。当然renderer本身能做的事情也不少，只不过这样说一下可能会好理解一点。相应的，我们的插件系统原本实现在Node.js端，是一个没有界面的工具，想要让它拥有「脸面」，其实也不过是在renderer进程里调用来自main进程里的插件系统暴露出来的api而已。这里我们举几个例子来说明。', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><h3 id=\"h3-u524Du53F0u9884u544A\"><a name=\"前台预告\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台预告</h3><p>前段时间，我用electron-vue开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。预计将会从几篇系列文章或方面来展开：</p>\r\n<ol>\r\n<li>electron-vue入门</li><li>Main进程和Renderer进程的简单开发</li><li>引入基于Lodash的JSON database——lowdb</li><li>跨平台的一些兼容措施</li><li>通过CI发布以及更新的方式</li><li>开发插件系统——CLI部分</li><li>开发插件系统——GUI部分</li><li>想到再写…</li></ol>\r\n<h1 id=\"h1-u8BF4u660E\"><a name=\"说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>说明</h1><p>PicGo是采用electron-vue开发的，所以如果你会vue，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如react、angular，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(Electron的主进程）应该还是能学习到相应的知识的。</p>\r\n<p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。并且如果没有看过前一篇CLI插件系统构建的朋友，需要先行阅读，本文涉及到的部分内容来自上一篇文章。</p>\r\n<h1 id=\"h1--require\"><a name=\"运行时的require\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行时的require</h1><p>我们之前构建的插件系统是基于Node.js端的。对于Electron而言，main进程可以认为拥有Node.js环境，所以我们首先要在main进程里将其引入。而对于PicGo而言，由于上传流程已经完全抽离到PicGo-Core这个库里了，所以原本存在于Electron端的上传部分就可以精简整合成调用PicGo-Core的api来实现上传部分的逻辑了。</p>\r\n<p>而在引入PicGo-Core的时候会遇到一个问题。在Electron端，由于我使用的脚手架是Electron-vue，它会将main进程和renderer进程都通过Webapck进行打包。由于PicGo-Core用于加载插件的部分使用的是require，在Node.js端很正常没问题。但是Webpack并不知道这些require是在运行时才需要调用的，它会认为这是构建时的「常规」require，也就会在打包的时候把你require的插件也打包进来。这样明显是不合理的，我们是运行时才require插件的，所以需要做一些手段来「绕开」Webpack的打包机制：<br> <code>const requireFunc = true ? require : require\r\n    const PicGo = requireFunc(&#39;picgo&#39;)</code><br>这样就可以避免PicGo-Core内部的require被Webpack也打包进去了。</p>\r\n<h1 id=\"h1--\"><a name=\"「前后端」分离\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>「前后端」分离</h1><p>Electron的main进程和renderer进程实际上你可以把它们看成我们平时Web开发的后端和前端。二者交流的工具也不再是Ajax，而是ipcMain和ipcRenderer。当然renderer本身能做的事情也不少，只不过这样说一下可能会好理解一点。相应的，我们的插件系统原本实现在Node.js端，是一个没有界面的工具，想要让它拥有「脸面」，其实也不过是在renderer进程里调用来自main进程里的插件系统暴露出来的api而已。这里我们举几个例子来说明。</p>\r\n', '39', '1', '0', '1', '1', '2019-04-16 01:10:49', '2019-04-09 13:58:45', '\\static\\bgpic\\1555348248704.jpg');
INSERT INTO `article` VALUES ('16', '1', 'Java知识——IO流操作', '# 基本概念\r\n　　Java中对文件的操作是以流的方式进行的。流是Java内存中的一组有序数据序列。Java将数据从源（文件、内存、键盘、网络）\r\n 读入到内存中，形成了流，然后将这些流还可以写到另外的目的地（文件、内存、控制台、网络），之所以称为流，是因为这个数据序列在不同时刻所操作的是源的不同部分。\r\n# 流的分类\r\n　　流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：\r\n　　1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。\r\n　　2、按照处理数据的单位不同分，字节流和字符流，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。\r\n　　3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的一种流，FileInputStream\r\n 是一个接点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。\r\n　　其实除了以上三种分类外，还有一些常常听到的一些分类比如：对象流、缓冲流、压缩流、文件流等等。其实都是节点流和处理流的子分类。当然你也可以创建新的流类型，只要你需要。\r\n# 关系\r\n　　不管流的分类是多么的丰富和复杂，其根源来自于四个基本的类。这个四个类的关系如下：\r\n　　   字节流  字符流\r\n　　输入流  InputStream  Reader\r\n　　输出流  OutputStream  Writer\r\n　　<!-- EndFragment-->\r\n# 字节流和字符流的相互转换\r\n　　1、从字节流到字符流：InputStreamReader、OutputStreamWriter类可以实现。\r\n　　2、从字符流到字节流：可以从字符流中获取char[]数组，转换为String，然后调用String的API函数getBytes() 获取到byte[]，然后就可以通过ByteArrayInputStream、\r\n ByteArrayOutputStream来实现到字节流的转换。\r\n# 实例\r\n附加：除了使用inputStreamreader和writer来将流转换为字符串意外还可以：\r\n```\r\ninputSteam in=。。\r\nByteArrayOutputStream outputStream=new ByteArrayOutputStream();\r\nbyte[] data=new byte[1024];\r\nint len=0;\r\nwhile((len=in.read(buffer))!=-1){\r\n    outputStream.write(data,0,len);\r\n}\r\nbyte[]data_b=outputStream.toByteArray();//转化为字节数组\r\nString data_s=new String(data,\"utf-8\");//转化为字符串\r\n```\r\n```\r\nFileInputStream in=openFileInput(\"文件名\")//InputStream in=connection.getInputStream();//读取文件和网络返回得数据\r\nInputStream in=xx.getInputStream();\r\nBufferedReader reader=new BufferedReader(new InputStreamReader(in));//使用inputstreamreader将字节转化为字符\r\nwhile(reader.readLine()!=null){\r\n    StringBuilder sb=new StringBuilder();//使用stringbuilder组装效率更高\r\n    sb.append(reader.readLine());\r\n}\r\n```\r\n```\r\nFileOutputStream out =openFileOutput(\"文件名\",文件操作模式);\r\nBufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));//先转换成了字符型在调用了缓冲字符输出流\r\nwriter.write(data);\r\n```\r\n\r\n------------\r\n\r\n', '<h1 id=\"h1-u57FAu672Cu6982u5FF5\"><a name=\"基本概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本概念</h1><p>　　Java中对文件的操作是以流的方式进行的。流是Java内存中的一组有序数据序列。Java将数据从源（文件、内存、键盘、网络）<br> 读入到内存中，形成了流，然后将这些流还可以写到另外的目的地（文件、内存、控制台、网络），之所以称为流，是因为这个数据序列在不同时刻所操作的是源的不同部分。</p>\r\n<h1 id=\"h1-u6D41u7684u5206u7C7B\"><a name=\"流的分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>流的分类</h1><p>　　流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：<br>　　1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。<br>　　2、按照处理数据的单位不同分，字节流和字符流，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。<br>　　3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的一种流，FileInputStream<br> 是一个接点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。<br>　　其实除了以上三种分类外，还有一些常常听到的一些分类比如：对象流、缓冲流、压缩流、文件流等等。其实都是节点流和处理流的子分类。当然你也可以创建新的流类型，只要你需要。</p>\r\n<h1 id=\"h1-u5173u7CFB\"><a name=\"关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关系</h1><p>　　不管流的分类是多么的丰富和复杂，其根源来自于四个基本的类。这个四个类的关系如下：<br>　　   字节流  字符流<br>　　输入流  InputStream  Reader<br>　　输出流  OutputStream  Writer<br>　　&lt;!-- EndFragment--&gt;</p>\r\n<h1 id=\"h1-u5B57u8282u6D41u548Cu5B57u7B26u6D41u7684u76F8u4E92u8F6Cu6362\"><a name=\"字节流和字符流的相互转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字节流和字符流的相互转换</h1><p>　　1、从字节流到字符流：InputStreamReader、OutputStreamWriter类可以实现。<br>　　2、从字符流到字节流：可以从字符流中获取char[]数组，转换为String，然后调用String的API函数getBytes() 获取到byte[]，然后就可以通过ByteArrayInputStream、<br> ByteArrayOutputStream来实现到字节流的转换。</p>\r\n<h1 id=\"h1-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h1><p>附加：除了使用inputStreamreader和writer来将流转换为字符串意外还可以：</p>\r\n<pre><code>inputSteam in=。。\r\nByteArrayOutputStream outputStream=new ByteArrayOutputStream();\r\nbyte[] data=new byte[1024];\r\nint len=0;\r\nwhile((len=in.read(buffer))!=-1){\r\n    outputStream.write(data,0,len);\r\n}\r\nbyte[]data_b=outputStream.toByteArray();//转化为字节数组\r\nString data_s=new String(data,&quot;utf-8&quot;);//转化为字符串\r\n</code></pre><pre><code>FileInputStream in=openFileInput(&quot;文件名&quot;)//InputStream in=connection.getInputStream();//读取文件和网络返回得数据\r\nInputStream in=xx.getInputStream();\r\nBufferedReader reader=new BufferedReader(new InputStreamReader(in));//使用inputstreamreader将字节转化为字符\r\nwhile(reader.readLine()!=null){\r\n    StringBuilder sb=new StringBuilder();//使用stringbuilder组装效率更高\r\n    sb.append(reader.readLine());\r\n}\r\n</code></pre><pre><code>FileOutputStream out =openFileOutput(&quot;文件名&quot;,文件操作模式);\r\nBufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));//先转换成了字符型在调用了缓冲字符输出流\r\nwriter.write(data);\r\n</code></pre><hr>\r\n', '8', '0', '0', '1', '1', '2019-04-09 20:45:22', '2017-10-07 16:04:25', '\\static\\bgpic\\1554813921801.jpg');
INSERT INTO `article` VALUES ('17', '1', 'Java总结篇系列：Java多线程（一）', '多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。\r\n# 线程的生命周期及五种基本状态\r\n关于Java中线程的生命周期，首先看一下下面这张较为经典的图：\r\n![](/Blog/static/pic/1554814153183.jpg)\r\n上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：\r\n## Java线程具有五中基本状态\r\n**新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\r\n\r\n**就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\r\n\r\n**运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\r\n\r\n**阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\r\n\r\n1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\r\n\r\n2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\r\n\r\n3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\r\n\r\n**死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\r\n\r\n# Java多线程的创建及启动\r\n\r\nJava中线程的创建常见有如三种基本形式\r\n**1.继承Thread类，重写该类的run()方法。**\r\n```\r\nclass MyThread extends Thread {\r\n    \r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\r\n                Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\r\n                myThread1.start();                     // 调用start()方法使得线程进入就绪状态\r\n                myThread2.start();                     // 调用start()方法使得线程进入就绪状态\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。\r\n\r\n**2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。**\r\n```\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\r\n                Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\r\n                Thread thread2 = new Thread(myRunnable);\r\n                thread1.start(); // 调用start()方法使得线程进入就绪状态\r\n                thread2.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable();\r\n                Thread thread = new MyThread(myRunnable);\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"in MyRunnable run\");\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n\r\nclass MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n    \r\n    public MyThread(Runnable runnable){\r\n        super(runnable);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"in MyThread run\");\r\n        for (i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n同样的，与实现Runnable接口创建线程方式相似，不同的地方在于\r\n\r\n`Thread thread = new MyThread(myRunnable);`\r\n\r\n那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。\r\n\r\n**3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程**\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Callable<Integer> myCallable = new MyCallable();    // 创建MyCallable对象\r\n        FutureTask<Integer> ft = new FutureTask<Integer>(myCallable); //使用FutureTask来包装MyCallable对象\r\n\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                Thread thread = new Thread(ft);   //FutureTask对象作为Thread对象的target创建新的线程\r\n                thread.start();                      //线程进入到就绪状态\r\n            }\r\n        }\r\n\r\n        System.out.println(\"主线程for循环执行完毕..\");\r\n        \r\n        try {\r\n            int sum = ft.get();            //取得新创建的新线程中的call()方法返回的结果\r\n            System.out.println(\"sum = \" + sum);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nclass MyCallable implements Callable<Integer> {\r\n    private int i = 0;\r\n\r\n    // 与run()方法不同的是，call()方法具有返回值\r\n    @Override\r\n    public Integer call() {\r\n        int sum = 0;\r\n        for (; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n```\r\n首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义：\r\n```\r\n public class FutureTask<V> implements RunnableFuture<V> {\r\n     \r\n   //....\r\n     \r\n }\r\n```\r\n于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。\r\n\r\n执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？\r\n\r\n原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。\r\n\r\n上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：**不能对同一线程对象两次调用start()方法。**\r\n# 三. Java多线程的就绪、运行和死亡状态\r\n就绪状态转换为运行状态：当此线程得到处理器资源；\r\n\r\n运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。\r\n\r\n运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。\r\n\r\n此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。\r\n\r\n由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如：\r\n```\r\npublic class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        MyRunnable myRunnable = new MyRunnable();\r\n        Thread thread = new Thread(myRunnable);\r\n        \r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n            if (i == 30) {\r\n                thread.start();\r\n            }\r\n            if(i == 40){\r\n                myRunnable.stopThread();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n\r\n    private boolean stop;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 100 && !stop; i++) {\r\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\r\n        }\r\n    }\r\n\r\n    public void stopThread() {\r\n        this.stop = true;\r\n    }\r\n\r\n}\r\n```\r\n\r\n------------\r\n\r\n', '<p>多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。</p>\r\n<h1 id=\"h1-u7EBFu7A0Bu7684u751Fu547Du5468u671Fu53CAu4E94u79CDu57FAu672Cu72B6u6001\"><a name=\"线程的生命周期及五种基本状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程的生命周期及五种基本状态</h1><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：<br><img src=\"/Blog/static/pic/1554814153183.jpg\" alt=\"\"><br>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p>\r\n<h2 id=\"h2-java-\"><a name=\"Java线程具有五中基本状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java线程具有五中基本状态</h2><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>\r\n<p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>\r\n<p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>\r\n<p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>\r\n<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>\r\n<p>2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>\r\n<p>3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>\r\n<p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>\r\n<h1 id=\"h1-java-\"><a name=\"Java多线程的创建及启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java多线程的创建及启动</h1><p>Java中线程的创建常见有如三种基本形式<br><strong>1.继承Thread类，重写该类的run()方法。</strong></p>\r\n<pre><code>class MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\r\n                Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\r\n                myThread1.start();                     // 调用start()方法使得线程进入就绪状态\r\n                myThread2.start();                     // 调用start()方法使得线程进入就绪状态\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。</p>\r\n<p><strong>2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。</strong></p>\r\n<pre><code>class MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\r\n                Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\r\n                Thread thread2 = new Thread(myRunnable);\r\n                thread1.start(); // 调用start()方法使得线程进入就绪状态\r\n                thread2.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。</p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Runnable myRunnable = new MyRunnable();\r\n                Thread thread = new MyThread(myRunnable);\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n    private int i = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(&quot;in MyRunnable run&quot;);\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n\r\nclass MyThread extends Thread {\r\n\r\n    private int i = 0;\r\n\r\n    public MyThread(Runnable runnable){\r\n        super(runnable);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(&quot;in MyThread run&quot;);\r\n        for (i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n}\r\n</code></pre><p>同样的，与实现Runnable接口创建线程方式相似，不同的地方在于</p>\r\n<p><code>Thread thread = new MyThread(myRunnable);</code></p>\r\n<p>那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。</p>\r\n<p><strong>3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程</strong></p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Callable&lt;Integer&gt; myCallable = new MyCallable();    // 创建MyCallable对象\r\n        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象\r\n\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                Thread thread = new Thread(ft);   //FutureTask对象作为Thread对象的target创建新的线程\r\n                thread.start();                      //线程进入到就绪状态\r\n            }\r\n        }\r\n\r\n        System.out.println(&quot;主线程for循环执行完毕..&quot;);\r\n\r\n        try {\r\n            int sum = ft.get();            //取得新创建的新线程中的call()方法返回的结果\r\n            System.out.println(&quot;sum = &quot; + sum);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nclass MyCallable implements Callable&lt;Integer&gt; {\r\n    private int i = 0;\r\n\r\n    // 与run()方法不同的是，call()方法具有返回值\r\n    @Override\r\n    public Integer call() {\r\n        int sum = 0;\r\n        for (; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n</code></pre><p>首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义：</p>\r\n<pre><code> public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {\r\n\r\n   //....\r\n\r\n }\r\n</code></pre><p>于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。</p>\r\n<p>执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？</p>\r\n<p>原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。</p>\r\n<p>上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：<strong>不能对同一线程对象两次调用start()方法。</strong></p>\r\n<h1 id=\"h1--java-\"><a name=\"三. Java多线程的就绪、运行和死亡状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三. Java多线程的就绪、运行和死亡状态</h1><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p>\r\n<p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p>\r\n<p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p>\r\n<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>\r\n<p>由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如：</p>\r\n<pre><code>public class ThreadTest {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        MyRunnable myRunnable = new MyRunnable();\r\n        Thread thread = new Thread(myRunnable);\r\n\r\n        for (int i = 0; i &lt; 100; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n            if (i == 30) {\r\n                thread.start();\r\n            }\r\n            if(i == 40){\r\n                myRunnable.stopThread();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass MyRunnable implements Runnable {\r\n\r\n    private boolean stop;\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) {\r\n            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\r\n        }\r\n    }\r\n\r\n    public void stopThread() {\r\n        this.stop = true;\r\n    }\r\n\r\n}\r\n</code></pre><hr>\r\n', '16', '0', '0', '1', '1', '2019-04-09 20:49:16', '2017-10-07 16:05:55', '\\static\\bgpic\\1554813612024.jpg');
INSERT INTO `article` VALUES ('27', '1', '使用vltur搭建vpn服务器', '# 前言\r\n本文主要介绍怎么进行部署vpn的服务器，部署完后可通过shadow进行翻墙。\r\n\r\n# 购买服务器\r\n首先登陆vltur的网址进行购买：\r\n网址:[https://www.vultr.com/](https://www.vultr.com/ \"https://www.vultr.com/\")\r\n![](/Blog/static/pic/1554807588889.png)\r\n接下来操作需要的信息是IP Address,Username和Password。这个页面不要关，等会还要用。\r\n\r\n# 远程连接服务器\r\n下载安装Xshell。\r\n安装完成后新建会话。依次填写图中信息。\r\n名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address,端口号选择22。\r\n![](/Blog/static/pic/1554807811090.png)\r\n\r\n点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username(一般都是root)，密码为之前的Password\r\n\r\n![](/Blog/static/pic/1554807978524.png)\r\n\r\n# 脚本快速安装\r\n### 脚本功能\r\n- 自定义端口号和密码\r\n- 全过程静默安装，不会打扰用户，你索要做的就是去听一首音乐。\r\n- 一次只允许一个shadowsocks进程，脚本会自动检测原来已经运行的进行并杀死。\r\n- 安装防火墙并开放所需要的端口。\r\n\r\n### 操作步骤\r\n![](/Blog/static/pic/1554808150337.png)\r\n\r\n# 具体图示\r\n![](/Blog/static/pic/1554808336491.png)\r\n\r\n![](/Blog/static/pic/1554808344385.png)\r\n\r\n# 脚本源码\r\n![](/Blog/static/pic/1554808350649.png)\r\n![](/Blog/static/pic/1554808381379.png)\r\n![](/Blog/static/pic/1554808386422.png)\r\n\r\n# 独立动手搭建\r\n### 搭建Shadowsocks服务\r\n安装组件：\r\n![](/Blog/static/pic/1554808575787.png)\r\n\r\n安装完成后配置服务器参数：\r\n![](/Blog/static/pic/1554808605419.png)\r\n\r\n写入如下配置：\r\n![](/Blog/static/pic/1554808628991.png)\r\n\r\n多端口的如下：\r\n![](/Blog/static/pic/1554808656371.png)\r\n\r\n其中的server字段与local_address填写之前的IP Adress。password是自己用于连接这个shadow socks的密码，自定义就好。\r\n其他的不需要更改。\r\n然后保存退出。\r\nvi的命令：按\"i\"进入编辑模式，编辑器按\"esc\"退出编辑模式，输入\":wq\"保存退出vi。\r\n\r\n#配置防火墙\r\n###安装防火墙\r\n![](/Blog/static/pic/1554808949806.png)\r\n###启动防火墙\r\n![](/Blog/static/pic/1554809526232.png)\r\n###开启防火墙相应的端口\r\n####方法一\r\n![](/Blog/static/pic/1554809009311.png)\r\n####方法二\r\n![](/Blog/static/pic/1554809274871.png)\r\n###启动Shadowsocks服务\r\n![](/Blog/static/pic/1554809221198.png)\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本文主要介绍怎么进行部署vpn的服务器，部署完后可通过shadow进行翻墙。</p>\r\n<h1 id=\"h1-u8D2Du4E70u670Du52A1u5668\"><a name=\"购买服务器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>购买服务器</h1><p>首先登陆vltur的网址进行购买：<br>网址:<a href=\"https://www.vultr.com/\" title=\"https://www.vultr.com/\">https://www.vultr.com/</a><br><img src=\"/Blog/static/pic/1554807588889.png\" alt=\"\"><br>接下来操作需要的信息是IP Address,Username和Password。这个页面不要关，等会还要用。</p>\r\n<h1 id=\"h1-u8FDCu7A0Bu8FDEu63A5u670Du52A1u5668\"><a name=\"远程连接服务器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>远程连接服务器</h1><p>下载安装Xshell。<br>安装完成后新建会话。依次填写图中信息。<br>名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address,端口号选择22。<br><img src=\"/Blog/static/pic/1554807811090.png\" alt=\"\"></p>\r\n<p>点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username(一般都是root)，密码为之前的Password</p>\r\n<p><img src=\"/Blog/static/pic/1554807978524.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u811Au672Cu5FEBu901Fu5B89u88C5\"><a name=\"脚本快速安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>脚本快速安装</h1><h3 id=\"h3-u811Au672Cu529Fu80FD\"><a name=\"脚本功能\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>脚本功能</h3><ul>\r\n<li>自定义端口号和密码</li><li>全过程静默安装，不会打扰用户，你索要做的就是去听一首音乐。</li><li>一次只允许一个shadowsocks进程，脚本会自动检测原来已经运行的进行并杀死。</li><li>安装防火墙并开放所需要的端口。</li></ul>\r\n<h3 id=\"h3-u64CDu4F5Cu6B65u9AA4\"><a name=\"操作步骤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>操作步骤</h3><p><img src=\"/Blog/static/pic/1554808150337.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u5177u4F53u56FEu793A\"><a name=\"具体图示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>具体图示</h1><p><img src=\"/Blog/static/pic/1554808336491.png\" alt=\"\"></p>\r\n<p><img src=\"/Blog/static/pic/1554808344385.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u811Au672Cu6E90u7801\"><a name=\"脚本源码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>脚本源码</h1><p><img src=\"/Blog/static/pic/1554808350649.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554808381379.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554808386422.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u72ECu7ACBu52A8u624Bu642Du5EFA\"><a name=\"独立动手搭建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>独立动手搭建</h1><h3 id=\"h3--shadowsocks-\"><a name=\"搭建Shadowsocks服务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>搭建Shadowsocks服务</h3><p>安装组件：<br><img src=\"/Blog/static/pic/1554808575787.png\" alt=\"\"></p>\r\n<p>安装完成后配置服务器参数：<br><img src=\"/Blog/static/pic/1554808605419.png\" alt=\"\"></p>\r\n<p>写入如下配置：<br><img src=\"/Blog/static/pic/1554808628991.png\" alt=\"\"></p>\r\n<p>多端口的如下：<br><img src=\"/Blog/static/pic/1554808656371.png\" alt=\"\"></p>\r\n<p>其中的server字段与local_address填写之前的IP Adress。password是自己用于连接这个shadow socks的密码，自定义就好。<br>其他的不需要更改。<br>然后保存退出。<br>vi的命令：按”i”进入编辑模式，编辑器按”esc”退出编辑模式，输入”:wq”保存退出vi。</p>\r\n<h1 id=\"h1-u914Du7F6Eu9632u706Bu5899\"><a name=\"配置防火墙\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置防火墙</h1><h3 id=\"h3-u5B89u88C5u9632u706Bu5899\"><a name=\"安装防火墙\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装防火墙</h3><p><img src=\"/Blog/static/pic/1554808949806.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u542Fu52A8u9632u706Bu5899\"><a name=\"启动防火墙\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动防火墙</h3><p><img src=\"/Blog/static/pic/1554809526232.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u5F00u542Fu9632u706Bu5899u76F8u5E94u7684u7AEFu53E3\"><a name=\"开启防火墙相应的端口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开启防火墙相应的端口</h3><h4 id=\"h4-u65B9u6CD5u4E00\"><a name=\"方法一\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法一</h4><p><img src=\"/Blog/static/pic/1554809009311.png\" alt=\"\"></p>\r\n<h4 id=\"h4-u65B9u6CD5u4E8C\"><a name=\"方法二\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法二</h4><p><img src=\"/Blog/static/pic/1554809274871.png\" alt=\"\"></p>\r\n<h3 id=\"h3--shadowsocks-\"><a name=\"启动Shadowsocks服务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动Shadowsocks服务</h3><p><img src=\"/Blog/static/pic/1554809221198.png\" alt=\"\"></p>\r\n', '31', '0', '0', '1', '1', '2019-04-09 19:32:09', '2018-11-25 20:56:50', '\\static\\bgpic\\1554809329268.jpg');
INSERT INTO `article` VALUES ('26', '1', '一些正则表达式', '# 校验数字的表达式\r\n\r\n数字：^[0-9]*$\r\nn位的数字：^\\\\d{n}$\r\n至少n位的数字：^\\\\d{n,}$\r\nm-n位的数字：^\\\\d{m,n}$\r\n零和非零开头的数字：^(0|[1-9][0-9]*)$\r\n非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\r\n带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\r\n正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\r\n有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\r\n有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\r\n非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\r\n非零的负整数：^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$\r\n非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\r\n非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\r\n非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\r\n非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\r\n正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\r\n负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\r\n浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\r\n\r\n# 校验字符的表达式\r\n汉字：^[\\u4e00-\\u9fa5]{0,}$\r\n英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\r\n长度为3-20的所有字符：^.{3,20}$\r\n由26个英文字母组成的字符串：^[A-Za-z]+$\r\n由26个大写英文字母组成的字符串：^[A-Z]+$\r\n由26个小写英文字母组成的字符串：^[a-z]+$\r\n由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\r\n由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\r\n中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\r\n中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\r\n可以输入含有^%&\',;=?$\\”等字符：[^%&\',;=?$\\x22]+\r\n禁止输入含有~的字符：[^~\\x22]+\r\n\r\n#特殊需求表达式\r\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\r\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\r\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\r\n手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\r\n电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\r\n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\r\n身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\r\n短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\r\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\r\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\\\w{5,17}$\r\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\r\n日期格式：^\\d{4}-\\\\d{1,2}-\\\\d{1,2}\r\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\r\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\r\n\r\n# 钱的输入格式：\r\n1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$ \r\n2.这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \r\n3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \r\n4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \r\n5.必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$ \r\n6.这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ \r\n7.这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \r\n8.1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \r\n9.备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里\r\n\r\n# 其他\r\nxml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\r\n中文字符的正则表达式：[\\u4e00-\\u9fa5]\r\n双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\r\n空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\r\nHTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\r\n首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\r\n腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\r\n中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\r\nIP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)\r\nIP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))', '<h1 id=\"h1-u6821u9A8Cu6570u5B57u7684u8868u8FBEu5F0F\"><a name=\"校验数字的表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>校验数字的表达式</h1><p>数字：^[0-9]<em>$<br>n位的数字：^\\d{n}$<br>至少n位的数字：^\\d{n,}$<br>m-n位的数字：^\\d{m,n}$<br>零和非零开头的数字：^(0|[1-9][0-9]</em>)$<br>非零开头的最多带两位小数的数字：^([1-9][0-9]<em>)+(.[0-9]{1,2})?$<br>带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$<br>正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$<br>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$<br>有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$<br>非零的正整数：^[1-9]\\d</em>$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$<br>非零的负整数：^-[1-9][]0-9″<em>$ 或 ^-[1-9]\\d</em>$<br>非负整数：^\\d+$ 或 ^[1-9]\\d<em>|0$<br>非正整数：^-[1-9]\\d</em>|0$ 或 ^((-\\d+)|(0+))$<br>非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d<em>.\\d</em>|0.\\d<em>[1-9]\\d</em>|0?.0+|0$<br>非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d<em>.\\d</em>|0.\\d<em>[1-9]\\d</em>))|0?.0+|0$<br>正浮点数：^[1-9]\\d<em>.\\d</em>|0.\\d<em>[1-9]\\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$<br>负浮点数：^-([1-9]\\d<em>.\\d</em>|0.\\d<em>[1-9]\\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$<br>浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d<em>.\\d</em>|0.\\d<em>[1-9]\\d</em>|0?.0+|0)$</p>\r\n<h1 id=\"h1-u6821u9A8Cu5B57u7B26u7684u8868u8FBEu5F0F\"><a name=\"校验字符的表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>校验字符的表达式</h1><p>汉字：^[\\u4e00-\\u9fa5]{0,}$<br>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$<br>长度为3-20的所有字符：^.{3,20}$<br>由26个英文字母组成的字符串：^[A-Za-z]+$<br>由26个大写英文字母组成的字符串：^[A-Z]+$<br>由26个小写英文字母组成的字符串：^[a-z]+$<br>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br>由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$<br>中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$<br>中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$<br>可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+<br>禁止输入含有~的字符：[^~\\x22]+</p>\r\n<h1 id=\"h1-u7279u6B8Au9700u6C42u8868u8FBEu5F0F\"><a name=\"特殊需求表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>特殊需求表达式</h1><p>Email地址：^\\w+([-+.]\\w+)<em>@\\w+([-.]\\w+)</em>.\\w+([-.]\\w+)<em>$<br>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?<br>InternetURL：[a-zA-z]+://[^\\s]</em> 或 ^<br>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$<br>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$<br>国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}<br>身份证号(15位、18位数字)：^\\d{15}|\\d{18}$<br>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$<br>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$<br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$<br>日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}<br>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</p>\r\n<h1 id=\"h1--\"><a name=\"钱的输入格式：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>钱的输入格式：</h1><p>1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]<em>$<br>2.这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]</em>)$<br>3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]<em>)$<br>4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$<br>5.必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$<br>6.这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$<br>7.这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})</em>(.[0-9]{1,2})?$<br>8.1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})<em>)(.[0-9]{1,2})?$<br>9.备注：这就是最终结果了，别忘了”+”可以用”</em>”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</p>\r\n<h1 id=\"h1-u5176u4ED6\"><a name=\"其他\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其他</h1><p>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$<br>中文字符的正则表达式：[\\u4e00-\\u9fa5]<br>双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>空白行的正则表达式：\\n\\s<em>\\r (可以用来删除空白行)<br>HTML标记的正则表达式：&lt;(\\S</em>?)[^&gt;]<em>&gt;.</em>?&lt;/\\1&gt;|&lt;.<em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br>首尾空白字符的正则表达式：^\\s</em>|\\s<em>$或(^\\s</em>)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br>腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)<br>中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)<br>IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)<br>IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</p>\r\n', '2', '0', '0', '1', '1', '2019-04-09 19:36:44', '2018-11-25 20:42:58', '\\static\\bgpic\\1554809765125.jpg');
INSERT INTO `article` VALUES ('28', '1', 'Linux常用的命令', '# 前言\r\n主要用来介绍一些长用的Linux命令\r\ntaskkill -f -im .exe    结束进程\r\ntasklist                查看进程\r\nslmgr.vbs               查看WINDOWS\r\nckeanmgr/sageset:1      清理磁盘\r\nformat f:/q             格式化磁盘\r\nvol f:                  查看磁盘\r\nconvert f:/fs:ntfs      FAT32转化为ntfs\r\nshutdown -s -t          关机\r\nnetstat   -ano|findstr  8080  查看端口8080被哪个pid给占用\r\ntaskkill  -pid  6856  -f  清理pid为6856掉进程\r\n\r\ndir mulu /s 列出目录大小\r\ndxdiag  查询电脑配置\r\n\r\n\r\nmaven:\r\n	src\r\n		-main\r\n			-java\r\n				-package\r\n		-test\r\n			-java\r\n				-package\r\n	resources\r\n	mvn -v查看版本\r\n	compile 编译\r\n	test 测试\r\n	package 打包\r\n	clean 删除target\r\n	install安装jar包到本地仓库中\r\n	创建目录\r\n	archetype:generate\r\n\r\n\r\nclean 清理项目\r\ndefault构建项目\r\nsite 生成项目站点\r\nmaven生命周期 clean,compile(编译),test(测试),package(打包，打包时依次执行编译和测试),install\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>主要用来介绍一些长用的Linux命令<br>taskkill -f -im .exe    结束进程<br>tasklist                查看进程<br>slmgr.vbs               查看WINDOWS<br>ckeanmgr/sageset:1      清理磁盘<br>format f:/q             格式化磁盘<br>vol f:                  查看磁盘<br>convert f:/fs:ntfs      FAT32转化为ntfs<br>shutdown -s -t          关机<br>netstat   -ano|findstr  8080  查看端口8080被哪个pid给占用<br>taskkill  -pid  6856  -f  清理pid为6856掉进程</p>\r\n<p>dir mulu /s 列出目录大小<br>dxdiag  查询电脑配置</p>\r\n<p>maven:<br>    src<br>        -main<br>            -java<br>                -package<br>        -test<br>            -java<br>                -package<br>    resources<br>    mvn -v查看版本<br>    compile 编译<br>    test 测试<br>    package 打包<br>    clean 删除target<br>    install安装jar包到本地仓库中<br>    创建目录<br>    archetype:generate</p>\r\n<p>clean 清理项目<br>default构建项目<br>site 生成项目站点<br>maven生命周期 clean,compile(编译),test(测试),package(打包，打包时依次执行编译和测试),install</p>\r\n', '2', '0', '0', '1', '1', '2019-04-09 18:17:01', '2018-11-25 20:58:22', '\\static\\bgpic\\1554805020639.jpg');
INSERT INTO `article` VALUES ('29', '1', 'Git上传本地项目以及修改', '# 前言\r\n本文主要用来介绍Git上传自己的项目到github上，以及当修改github项目。\r\n# 第一步\r\n   我们需要先创建一个本地的版本库（其实也就是一个文件夹）。\r\n你可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。\r\n![](/Blog/static/pic/1554803406981.png)\r\n现在我通过命令行在桌面新建一个TEST文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹\r\n![](/Blog/static/pic/1554803413243.png)\r\n\r\n#   第二步\r\n通过命令git init把这个文件夹变成Git可管理的仓库\r\n  ![](/Blog/static/pic/1554803430257.png)\r\n  \r\n   这时你会发现TEST里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。\r\n![](/Blog/static/pic/1554803448571.png)\r\n   \r\n# 第三步\r\n这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。\r\n![](/Blog/static/pic/1554803613139.png)\r\n\r\n这里提示你虽然把项目粘贴过来了，但还没有add到Git仓库上，然后我们通过git add .把刚才复制过来的项目全部添加到仓库上。\r\n![](/Blog/static/pic/1554803639105.png)\r\n\r\n查看当前的git状态\r\n![](/Blog/static/pic/1554803671964.png)\r\n\r\n#  第四步\r\n 用git commit把项目提交到仓库。\r\n \r\n ![](/Blog/static/pic/1554803693751.png)\r\n \r\n  **-m**后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 好了，我们本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github）\r\n 由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下。\r\n \r\n#  第五步\r\n创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建\r\n`\r\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\r\n`\r\n然后一路回车。这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件   \r\n![](/Blog/static/pic/1554803811593.png)\r\n\r\n#   第六步\r\n登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：\r\n![](/Blog/static/pic/1554803845547.png)\r\n![](/Blog/static/pic/1554803891121.png)\r\n![](/Blog/static/pic/1554803906152.png)\r\n![](/Blog/static/pic/1554803917717.png)\r\n\r\n#  第七步\r\n在Github上创建一个Git仓库。\r\n\r\n 你可以直接点New repository来创建，比如我创建了一个TEST2的仓库（因为我里面已经有了一个test的仓库，所以不能再创建TEST仓库）。\r\n ![](/Blog/static/pic/1554803967085.png)\r\n \r\n#  第八步\r\n\r\n在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入：\r\n\r\n`$ git remote add origin https://github.com/guyibang/TEST2.git`\r\n\r\n![](/Blog/static/pic/1554804023151.png)\r\n\r\n 注意origin后面加的是你Github上创建好的仓库的地址。\r\n \r\n ![](/Blog/static/pic/1554804043581.png)\r\n \r\n#   第九步\r\n\r\n关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：\r\n\r\n`$ git push -u origin master`\r\n\r\n  由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：\r\n  \r\n`  $ git push origin master`\r\n\r\n 上传项目的过程可能需要等一段时间，完成之后是这样的：\r\n ![](/Blog/static/pic/1554804164220.png)\r\n \r\n   这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了：\r\n   \r\n   ![](/Blog/static/pic/1554804193426.png)\r\n   \r\n至此就完成了将本地项目上传到Github的整个过程。\r\n另外，这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to github.com/guyibang/Test.git\r\n\r\n![](/Blog/static/pic/1554804313627.png)\r\n\r\n   这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：\r\n   \r\n`$ git pull --rebase origin master`\r\n![](/Blog/static/pic/1554804366856.png)\r\n\r\n  这时你再push就能成功了。\r\n#   删除已经上传好的文件夹\r\n1. 在你的本地目录下手动删除你要删除的东西\r\n2. 在客户端输入：git commit -a -m \"A file was deleted\"\r\n3. 在客户端：git push\r\n4. 在客户端输入你的用户名和密码\r\n5. 如果有一下情况需要进行合并\r\n\r\n### 提交删除\r\n![](/Blog/static/pic/1554804453876.png)\r\n\r\n### 合并分支\r\n` git pull origin master`\r\n\r\n![](/Blog/static/pic/1554804594167.png)\r\n\r\n### 上传\r\n\r\n`Git push`\r\n\r\n![](/Blog/static/pic/1554804627758.png)\r\n\r\n退出蓝色框输入 `:wq`\r\n\r\n------------\r\n\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本文主要用来介绍Git上传自己的项目到github上，以及当修改github项目。</p>\r\n<h1 id=\"h1-u7B2Cu4E00u6B65\"><a name=\"第一步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第一步</h1><p>   我们需要先创建一个本地的版本库（其实也就是一个文件夹）。<br>你可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。<br><img src=\"/Blog/static/pic/1554803406981.png\" alt=\"\"><br>现在我通过命令行在桌面新建一个TEST文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹<br><img src=\"/Blog/static/pic/1554803413243.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E8Cu6B65\"><a name=\"第二步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二步</h1><p>通过命令git init把这个文件夹变成Git可管理的仓库<br>  <img src=\"/Blog/static/pic/1554803430257.png\" alt=\"\"></p>\r\n<p>   这时你会发现TEST里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。<br><img src=\"/Blog/static/pic/1554803448571.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E09u6B65\"><a name=\"第三步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第三步</h1><p>这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。<br><img src=\"/Blog/static/pic/1554803613139.png\" alt=\"\"></p>\r\n<p>这里提示你虽然把项目粘贴过来了，但还没有add到Git仓库上，然后我们通过git add .把刚才复制过来的项目全部添加到仓库上。<br><img src=\"/Blog/static/pic/1554803639105.png\" alt=\"\"></p>\r\n<p>查看当前的git状态<br><img src=\"/Blog/static/pic/1554803671964.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu56DBu6B65\"><a name=\"第四步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第四步</h1><p> 用git commit把项目提交到仓库。</p>\r\n<p> <img src=\"/Blog/static/pic/1554803693751.png\" alt=\"\"></p>\r\n<p>  <strong>-m</strong>后面引号里面是本次提交的注释内容，这个可以不写，但最好写上，不然会报错，详情自行Google。 好了，我们本地Git仓库这边的工作做完了，下面就到了连接远程仓库（也就是连接Github）<br> 由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下。</p>\r\n<h1 id=\"h1-u7B2Cu4E94u6B65\"><a name=\"第五步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第五步</h1><p>创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建<br><code>$ ssh-keygen -t rsa -C &quot;<a href=\"mailto:youremail@example.com\">youremail@example.com</a>&quot;</code><br>然后一路回车。这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件<br><img src=\"/Blog/static/pic/1554803811593.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu516Du6B65\"><a name=\"第六步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第六步</h1><p>登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：<br><img src=\"/Blog/static/pic/1554803845547.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803891121.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803906152.png\" alt=\"\"><br><img src=\"/Blog/static/pic/1554803917717.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E03u6B65\"><a name=\"第七步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第七步</h1><p>在Github上创建一个Git仓库。</p>\r\n<p> 你可以直接点New repository来创建，比如我创建了一个TEST2的仓库（因为我里面已经有了一个test的仓库，所以不能再创建TEST仓库）。<br> <img src=\"/Blog/static/pic/1554803967085.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu516Bu6B65\"><a name=\"第八步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第八步</h1><p>在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入：</p>\r\n<p><code>$ git remote add origin https://github.com/guyibang/TEST2.git</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804023151.png\" alt=\"\"></p>\r\n<p> 注意origin后面加的是你Github上创建好的仓库的地址。</p>\r\n<p> <img src=\"/Blog/static/pic/1554804043581.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u7B2Cu4E5Du6B65\"><a name=\"第九步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第九步</h1><p>关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：</p>\r\n<p><code>$ git push -u origin master</code></p>\r\n<p>  由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：</p>\r\n<p><code>$ git push origin master</code></p>\r\n<p> 上传项目的过程可能需要等一段时间，完成之后是这样的：<br> <img src=\"/Blog/static/pic/1554804164220.png\" alt=\"\"></p>\r\n<p>   这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了：</p>\r\n<p>   <img src=\"/Blog/static/pic/1554804193426.png\" alt=\"\"></p>\r\n<p>至此就完成了将本地项目上传到Github的整个过程。<br>另外，这里有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to github.com/guyibang/Test.git</p>\r\n<p><img src=\"/Blog/static/pic/1554804313627.png\" alt=\"\"></p>\r\n<p>   这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：</p>\r\n<p><code>$ git pull --rebase origin master</code><br><img src=\"/Blog/static/pic/1554804366856.png\" alt=\"\"></p>\r\n<p>  这时你再push就能成功了。</p>\r\n<h1 id=\"h1-u5220u9664u5DF2u7ECFu4E0Au4F20u597Du7684u6587u4EF6u5939\"><a name=\"删除已经上传好的文件夹\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除已经上传好的文件夹</h1><ol>\r\n<li>在你的本地目录下手动删除你要删除的东西</li><li>在客户端输入：git commit -a -m “A file was deleted”</li><li>在客户端：git push</li><li>在客户端输入你的用户名和密码</li><li>如果有一下情况需要进行合并</li></ol>\r\n<h3 id=\"h3-u63D0u4EA4u5220u9664\"><a name=\"提交删除\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提交删除</h3><p><img src=\"/Blog/static/pic/1554804453876.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u5408u5E76u5206u652F\"><a name=\"合并分支\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>合并分支</h3><p><code>git pull origin master</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804594167.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u4E0Au4F20\"><a name=\"上传\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>上传</h3><p><code>Git push</code></p>\r\n<p><img src=\"/Blog/static/pic/1554804627758.png\" alt=\"\"></p>\r\n<p>退出蓝色框输入 <code>:wq</code></p>\r\n<hr>\r\n', '9', '0', '0', '1', '1', '2019-04-09 20:25:05', '2018-11-25 21:00:24', '\\static\\bgpic\\1554804769345.png');
INSERT INTO `article` VALUES ('30', '1', 'Juqery的一些插件', '# VueJS表头固定的数据表格 可按每列排序\r\n\r\n在网页中，表格（table）大部分用于数据的展示和处理，在jQuery的时代，用于表格的插件非常多。今天我们介绍一个基于VueJS的表格应用，它的特点是表格表头固定，也就是说当表格数据行很多时，页面下拉时表头可以固定，方便查看每一列的数据。另外还有特点是我们可以对每一个列进行排序。同时，这款JS表格的外观也不错，可以很好用到你的项目中。VueJS还是挺灵活的。\r\n![](/Blog/static/pic/1554802177854.png)\r\n链接：[https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar](https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar \"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\")\r\n\r\n# 基于Three.js和HTML5 Canvas的3D水晶球体\r\n今天给大家分享一个很酷的HTML5 Canvas 3D动画，它同样是一个基于Three.js制作的动画特效。在Canvas上有一个用许多长度各异的水晶柱形组成的球体，我们还可以用鼠标拖拽球体来从不同角度观察球面，还可以用鼠标滚轮来缩放球面。还有一个特性就是，双击球面可以改变水晶面的颜色，同时水晶面上会随着旋转的角度出现亮光，更加凸显出其3D立体的视觉效果。\r\n![](/Blog/static/pic/1554802278738.png)\r\n链接:\r\n[https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar](https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar \"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\")\r\n\r\n# HTML5 Emoji自定义表情编辑器\r\nEmoji表情在网页中使用十分广泛，它由一些简单的字符组成许多表情，例如笑脸、蛋糕等。今天我们要介绍一个基于HTML5和CSS3的Emoji自定义表情编辑器，初始默认是一个人脸，你可以在编辑器中为该人脸表情添加和改变各种面部表情，例如带上帽子，噘嘴等，甚至可以将其他任意Emoji表情添加上去，用起来非常不错。但是如果可以将编辑好的表情导出就更加完美了。\r\n![](/Blog/static/pic/1554802322011.png)\r\n链接:\r\n[https://www.html5tricks.com/download/html5-emoji-editor.rar](https://www.html5tricks.com/download/html5-emoji-editor.rar \"https://www.html5tricks.com/download/html5-emoji-editor.rar\")\r\n\r\n# HTML5和CSS3实现的自定义3D滑杆控件\r\n之前我们分享过一些比较有意思的滑杆控件，比如这款基于VueJS的滑块组件就非常不错。滑杆这种控件一般用在范围选取上面，比如结合图表生成一定范围的数据。今天我们分享的这个滑杆控件自定义程度非常高，特别是使用了CSS3的3D特性，让整一个滑杆控件效果更加炫酷。\r\n![](/Blog/static/pic/1554802370966.png)\r\n链接:\r\n[https://www.html5tricks.com/download/html5-css3-3d-slider.rar](https://www.html5tricks.com/download/html5-css3-3d-slider.rar \"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\")\r\n\r\n# CSS3和SVG实现的圆环菜单动画\r\n网页菜单的样式真实多种多样，特别是HTML5和CSS3的流行，让网页菜单的外观更加丰富多彩了。今天我们要给大家分享一个基于CSS3和SVG的圆环形状的菜单，在圆环上一共有7个节点，表示菜单项，当鼠标滑过或者点击其中一个节点时，就会弹出文字菜单项，圆环形状和节点都是采用SVG绘制而成，动画效果也非常不错。\r\n![](/Blog/static/pic/1554802423628.png)\r\n链接:\r\n[https://www.html5tricks.com/download/css3-svg-circle-menu.rar](https://www.html5tricks.com/download/css3-svg-circle-menu.rar \"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\")\r\n\r\n# 超酷的CSS3复古风格和字体的3D按钮\r\n我们分享过很多基于CSS3的3D按钮，很多都非常漂亮，例如这篇7款外观迷人的HTML5/CSS3 3D按钮特效文章中就收藏了不少。这次我们要带来一款也是基于CSS3的3D按钮，它有着复古的风格和字体。第一个按钮根据光标在悬停时的位置向左或向右倾斜，它的风格类似于老式游戏机按钮。 这些按钮配置了sm，md，lg大小类以及bootstrap-esque类，如primary，secondary，dangerous，warning，success和info。第二个按钮是一个加载程序按钮，按下它时会有自己的进度条。 它只会向中心推动，但随后向上打开，在它的正面显示一个进度条。 根据操作的成功与否，它将在完成时显示具体信息。\r\n![](/Blog/static/pic/1554802460603.png)\r\n链接：\r\n[https://www.html5tricks.com/download/css3-3d-retro-button.rar](https://www.html5tricks.com/download/css3-3d-retro-button.rar \"https://www.html5tricks.com/download/css3-3d-retro-button.rar\")\r\n\r\n# 基于CSS3的iOS风格开关切换按钮\r\n之前我们为大家分享过一些外观富有创意而且实用的CSS3开关切换按钮，比如这个纯CSS3表情切换样式的开关切换按钮和多组超具创意的CSS3开关切换按钮。这次我们带来另外一款基于CSS3的iOS风格开关切换按钮，它的样式是iOS风格的，其中一个特点是你不能同时选中这3项。\r\n![](/Blog/static/pic/1554802501974.png)\r\n链接:\r\n[https://www.html5tricks.com/download/css3-ios-switch-button.rar](https://www.html5tricks.com/download/css3-ios-switch-button.rar \"https://www.html5tricks.com/download/css3-ios-switch-button.rar\")\r\n\r\n# Echarts数据管理图表界面 多种图表使用示例\r\n早些时候，我们给大家分享过一款基于Echarts的HTML5 Canvas中国地图，非常实用。这次我们继续给大家带来一些基于Echarts的数据管理图表界面，这个界面包含很多基于Echarts的图表示例，有柱形图、饼图和地图等。\r\n![](/Blog/static/pic/1554802562535.png)\r\n链接:\r\n[https://www.html5tricks.com/download/echarts-data-graphic.rar](https://www.html5tricks.com/download/echarts-data-graphic.rar \"https://www.html5tricks.com/download/echarts-data-graphic.rar\")\r\n\r\n# CSS3根据渐变序列猜颜色游戏\r\n今天给大家分享一个基于CSS3和JavaScript的颜色辨析游戏，已知3个一组的方块，前面2个方块涂有相近的两种颜色，你根据这两种颜色序列的递减情况，猜测第三个方块的颜色是什么，并从下面的方块中选择你认为最接近的颜色，一起来测试一下自己的辨色能力吧。\r\n![](/Blog/static/pic/1554802603858.png)\r\n链接:\r\n[https://www.html5tricks.com/download/color-sequence.rar](https://www.html5tricks.com/download/color-sequence.rar \"https://www.html5tricks.com/download/color-sequence.rar\")\r\n\r\n', '<h1 id=\"h1-vuejs-\"><a name=\"VueJS表头固定的数据表格 可按每列排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>VueJS表头固定的数据表格 可按每列排序</h1><p>在网页中，表格（table）大部分用于数据的展示和处理，在jQuery的时代，用于表格的插件非常多。今天我们介绍一个基于VueJS的表格应用，它的特点是表格表头固定，也就是说当表格数据行很多时，页面下拉时表头可以固定，方便查看每一列的数据。另外还有特点是我们可以对每一个列进行排序。同时，这款JS表格的外观也不错，可以很好用到你的项目中。VueJS还是挺灵活的。<br><img src=\"/Blog/static/pic/1554802177854.png\" alt=\"\"><br>链接：<a href=\"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\" title=\"https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar\">https://www.html5tricks.com/download/vuejs-sticky-sort-table.rar</a></p>\r\n<h1 id=\"h1--three-js-html5-canvas-3d-\"><a name=\"基于Three.js和HTML5 Canvas的3D水晶球体\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基于Three.js和HTML5 Canvas的3D水晶球体</h1><p>今天给大家分享一个很酷的HTML5 Canvas 3D动画，它同样是一个基于Three.js制作的动画特效。在Canvas上有一个用许多长度各异的水晶柱形组成的球体，我们还可以用鼠标拖拽球体来从不同角度观察球面，还可以用鼠标滚轮来缩放球面。还有一个特性就是，双击球面可以改变水晶面的颜色，同时水晶面上会随着旋转的角度出现亮光，更加凸显出其3D立体的视觉效果。<br><img src=\"/Blog/static/pic/1554802278738.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\" title=\"https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar\">https://www.html5tricks.com/download/threejs-canvas-3d-crystals.rar</a></p>\r\n<h1 id=\"h1-html5-emoji-\"><a name=\"HTML5 Emoji自定义表情编辑器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML5 Emoji自定义表情编辑器</h1><p>Emoji表情在网页中使用十分广泛，它由一些简单的字符组成许多表情，例如笑脸、蛋糕等。今天我们要介绍一个基于HTML5和CSS3的Emoji自定义表情编辑器，初始默认是一个人脸，你可以在编辑器中为该人脸表情添加和改变各种面部表情，例如带上帽子，噘嘴等，甚至可以将其他任意Emoji表情添加上去，用起来非常不错。但是如果可以将编辑好的表情导出就更加完美了。<br><img src=\"/Blog/static/pic/1554802322011.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/html5-emoji-editor.rar\" title=\"https://www.html5tricks.com/download/html5-emoji-editor.rar\">https://www.html5tricks.com/download/html5-emoji-editor.rar</a></p>\r\n<h1 id=\"h1-html5-css3-3d-\"><a name=\"HTML5和CSS3实现的自定义3D滑杆控件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML5和CSS3实现的自定义3D滑杆控件</h1><p>之前我们分享过一些比较有意思的滑杆控件，比如这款基于VueJS的滑块组件就非常不错。滑杆这种控件一般用在范围选取上面，比如结合图表生成一定范围的数据。今天我们分享的这个滑杆控件自定义程度非常高，特别是使用了CSS3的3D特性，让整一个滑杆控件效果更加炫酷。<br><img src=\"/Blog/static/pic/1554802370966.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\" title=\"https://www.html5tricks.com/download/html5-css3-3d-slider.rar\">https://www.html5tricks.com/download/html5-css3-3d-slider.rar</a></p>\r\n<h1 id=\"h1-css3-svg-\"><a name=\"CSS3和SVG实现的圆环菜单动画\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CSS3和SVG实现的圆环菜单动画</h1><p>网页菜单的样式真实多种多样，特别是HTML5和CSS3的流行，让网页菜单的外观更加丰富多彩了。今天我们要给大家分享一个基于CSS3和SVG的圆环形状的菜单，在圆环上一共有7个节点，表示菜单项，当鼠标滑过或者点击其中一个节点时，就会弹出文字菜单项，圆环形状和节点都是采用SVG绘制而成，动画效果也非常不错。<br><img src=\"/Blog/static/pic/1554802423628.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\" title=\"https://www.html5tricks.com/download/css3-svg-circle-menu.rar\">https://www.html5tricks.com/download/css3-svg-circle-menu.rar</a></p>\r\n<h1 id=\"h1--css3-3d-\"><a name=\"超酷的CSS3复古风格和字体的3D按钮\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>超酷的CSS3复古风格和字体的3D按钮</h1><p>我们分享过很多基于CSS3的3D按钮，很多都非常漂亮，例如这篇7款外观迷人的HTML5/CSS3 3D按钮特效文章中就收藏了不少。这次我们要带来一款也是基于CSS3的3D按钮，它有着复古的风格和字体。第一个按钮根据光标在悬停时的位置向左或向右倾斜，它的风格类似于老式游戏机按钮。 这些按钮配置了sm，md，lg大小类以及bootstrap-esque类，如primary，secondary，dangerous，warning，success和info。第二个按钮是一个加载程序按钮，按下它时会有自己的进度条。 它只会向中心推动，但随后向上打开，在它的正面显示一个进度条。 根据操作的成功与否，它将在完成时显示具体信息。<br><img src=\"/Blog/static/pic/1554802460603.png\" alt=\"\"><br>链接：<br><a href=\"https://www.html5tricks.com/download/css3-3d-retro-button.rar\" title=\"https://www.html5tricks.com/download/css3-3d-retro-button.rar\">https://www.html5tricks.com/download/css3-3d-retro-button.rar</a></p>\r\n<h1 id=\"h1--css3-ios-\"><a name=\"基于CSS3的iOS风格开关切换按钮\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基于CSS3的iOS风格开关切换按钮</h1><p>之前我们为大家分享过一些外观富有创意而且实用的CSS3开关切换按钮，比如这个纯CSS3表情切换样式的开关切换按钮和多组超具创意的CSS3开关切换按钮。这次我们带来另外一款基于CSS3的iOS风格开关切换按钮，它的样式是iOS风格的，其中一个特点是你不能同时选中这3项。<br><img src=\"/Blog/static/pic/1554802501974.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/css3-ios-switch-button.rar\" title=\"https://www.html5tricks.com/download/css3-ios-switch-button.rar\">https://www.html5tricks.com/download/css3-ios-switch-button.rar</a></p>\r\n<h1 id=\"h1-echarts-\"><a name=\"Echarts数据管理图表界面 多种图表使用示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Echarts数据管理图表界面 多种图表使用示例</h1><p>早些时候，我们给大家分享过一款基于Echarts的HTML5 Canvas中国地图，非常实用。这次我们继续给大家带来一些基于Echarts的数据管理图表界面，这个界面包含很多基于Echarts的图表示例，有柱形图、饼图和地图等。<br><img src=\"/Blog/static/pic/1554802562535.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/echarts-data-graphic.rar\" title=\"https://www.html5tricks.com/download/echarts-data-graphic.rar\">https://www.html5tricks.com/download/echarts-data-graphic.rar</a></p>\r\n<h1 id=\"h1-css3-\"><a name=\"CSS3根据渐变序列猜颜色游戏\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CSS3根据渐变序列猜颜色游戏</h1><p>今天给大家分享一个基于CSS3和JavaScript的颜色辨析游戏，已知3个一组的方块，前面2个方块涂有相近的两种颜色，你根据这两种颜色序列的递减情况，猜测第三个方块的颜色是什么，并从下面的方块中选择你认为最接近的颜色，一起来测试一下自己的辨色能力吧。<br><img src=\"/Blog/static/pic/1554802603858.png\" alt=\"\"><br>链接:<br><a href=\"https://www.html5tricks.com/download/color-sequence.rar\" title=\"https://www.html5tricks.com/download/color-sequence.rar\">https://www.html5tricks.com/download/color-sequence.rar</a></p>\r\n', '6', '0', '0', '1', '1', '2019-04-09 17:39:53', '2018-11-25 21:01:24', '\\static\\bgpic\\1554802637431.png');
INSERT INTO `article` VALUES ('31', '1', '用git命令行上传本地代码到github，并且修改某个文件后将再将该文件提交', '# 一、用git命令行上传本地代码到github\r\n在上传之前有必要解释一下相关概念：git分为三部分，一部分是自己的文件，另外一部分是缓存区，最后一个是本地库。git add xx操作是将本地文件添加到缓存区；git commit操作是将缓存区的文件提交到本地仓库；git push操作是将本地仓库的内容推送到远程仓库。\r\n\r\n1.进入本地的项目目录，右键“Git Bash here”,调出git命令行界面，然后输入\r\n\r\n`git init`\r\n\r\n2.就是将目录下的所有文件添加到缓存区，也可以将“.”换成具体的文件名\r\n\r\n`git add .`\r\n\r\n3.将上面缓存区的文件提交到本地仓库\r\n\r\n`git commit -m \"注释语句\"`\r\n\r\n4.去github上创建自己的本地仓库repository\r\n\r\n5.将本地的仓库关联到github上。后面的https链接换成刚刚自己在github上创建的仓库url地址\r\n\r\n`git remote add origin`\r\n\r\n[https://github.com/yuexijun/myTest.git](https://github.com/yuexijun/myTest.git \"https://github.com/yuexijun/myTest.git\")\r\n\r\n6.上传到github之前先pull一下远程仓库，执行如下命令\r\n\r\n`git pull origin master`\r\n\r\n7.上传代码到github远程仓库\r\n\r\n`git push -u origin master`\r\n\r\n执行完后，如果没有异常，等待执行完就上传成功了，中间可能让你输入用户名和密码，你只要输入点击继续就行了。\r\n\r\n最后贴上我上传成功后的截图：\r\n![](/Blog/static/pic/1554801760202.png)\r\n\r\n# 二、用git命令行将修改的某个文件提交\r\n步骤请看如下截图：\r\n![](/Blog/static/pic/1554801821996.png)\r\n上面的git push origin master命令没有成功的话，试试这个命令直接git push，推送成功，本人亲自测。\r\n', '<h1 id=\"h1--git-github\"><a name=\"一、用git命令行上传本地代码到github\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、用git命令行上传本地代码到github</h1><p>在上传之前有必要解释一下相关概念：git分为三部分，一部分是自己的文件，另外一部分是缓存区，最后一个是本地库。git add xx操作是将本地文件添加到缓存区；git commit操作是将缓存区的文件提交到本地仓库；git push操作是将本地仓库的内容推送到远程仓库。</p>\r\n<p>1.进入本地的项目目录，右键“Git Bash here”,调出git命令行界面，然后输入</p>\r\n<p><code>git init</code></p>\r\n<p>2.就是将目录下的所有文件添加到缓存区，也可以将“.”换成具体的文件名</p>\r\n<p><code>git add .</code></p>\r\n<p>3.将上面缓存区的文件提交到本地仓库</p>\r\n<p><code>git commit -m &quot;注释语句&quot;</code></p>\r\n<p>4.去github上创建自己的本地仓库repository</p>\r\n<p>5.将本地的仓库关联到github上。后面的https链接换成刚刚自己在github上创建的仓库url地址</p>\r\n<p><code>git remote add origin</code></p>\r\n<p><a href=\"https://github.com/yuexijun/myTest.git\" title=\"https://github.com/yuexijun/myTest.git\">https://github.com/yuexijun/myTest.git</a></p>\r\n<p>6.上传到github之前先pull一下远程仓库，执行如下命令</p>\r\n<p><code>git pull origin master</code></p>\r\n<p>7.上传代码到github远程仓库</p>\r\n<p><code>git push -u origin master</code></p>\r\n<p>执行完后，如果没有异常，等待执行完就上传成功了，中间可能让你输入用户名和密码，你只要输入点击继续就行了。</p>\r\n<p>最后贴上我上传成功后的截图：<br><img src=\"/Blog/static/pic/1554801760202.png\" alt=\"\"></p>\r\n<h1 id=\"h1--git-\"><a name=\"二、用git命令行将修改的某个文件提交\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、用git命令行将修改的某个文件提交</h1><p>步骤请看如下截图：<br><img src=\"/Blog/static/pic/1554801821996.png\" alt=\"\"><br>上面的git push origin master命令没有成功的话，试试这个命令直接git push，推送成功，本人亲自测。</p>\r\n', '6', '0', '0', '1', '1', '2019-04-09 17:24:37', '2018-11-25 21:02:40', '\\static\\bgpic\\1554801877297.jpg');
INSERT INTO `article` VALUES ('32', '1', 'SpringMVC实现ajax上传图片实时预览', '# 前言\r\n本文介绍使用 SpringMVC + ajaxfileupload.js 实现 ajax 上传文件。 先看效果图\r\n![](/Blog/static/pic/1554800492432.gif)\r\n  点击上传文件框，触发上传文件方法，然后后台返回图片的 url，进行显示。\r\n  \r\n# 前台代码\r\n1、add.jsp (或者 html 文件)\r\n```\r\n<input type=\"file\" name=\"file\" id=\"file\" onchange=\"uploadImg()\">\r\n<input type=\"hidden\" name=\"avatar\" id=\"avatar\">\r\n<img src=\"\" alt=\"\" id=\"avatarShow\" width=\"100px\" height=\"100px\">\r\n```\r\n2、引入 jquery 和 ajaxfileupload.js\r\n```\r\n<script src=\"${pageContext.request.contextPath}/static/js/jquery.min.js\"></script>\r\n<script src=\"${pageContext.request.contextPath}/static/js/ajaxfileupload.js\"></script>\r\n```\r\n这里给出 ajaxfileupload.js 下载地址，网上也有下载 这里有个坑，详情看这里 使用ajaxfileupload.js上传文件成功之后，没有执行success方法。\r\n```\r\n<script>\r\n    //ajax提交信息\r\n    function uploadImg() {\r\n        if($(\"#file\").val() != \"\") {\r\n            $.ajaxFileUpload({\r\n                type: \"POST\",\r\n                url:\"${pageContext.request.contextPath}/uploadFile\",\r\n                dataType: \"json\",\r\n                fileElementId:\"file\",  // 文件的id\r\n                success: function(d){\r\n                    if(d.code == 0) {\r\n                        //alert(\"上传成功\");\r\n                        //图片显示\r\n                        $(\"#avatar\").attr(\"value\",d.data.url);\r\n                        $(\"#avatarShow\").attr(\"src\",d.data.url);\r\n                    }\r\n                },\r\n                error: function () {\r\n                    alert(\"上传失败\");\r\n                },\r\n            });\r\n        } else {\r\n            alert(\"请先选择文件\");\r\n        }\r\n    }\r\n\r\n</script>\r\n```\r\n需要放在 上面两个库的后面 注意： ① type 填 post ② 第8行的 dataType 是小写的 json，不要写成大写的啦 ③ 第9行的 fileElementId 填文件框的id ④ 先确保 url 没写错  \r\n\r\n# 后台代码\r\n1、给 maven 添加依赖 ①、首先需要导入 json 的依赖\r\n```\r\n<!-- jackson -->\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-databind</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-core</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>com.fasterxml.jackson.core</groupId>\r\n      <artifactId>jackson-annotations</artifactId>\r\n      <version>2.5.0</version>\r\n    </dependency>\r\n```\r\n  ②、然后需要上传文件的依赖\r\n  ```\r\n<dependency>\r\n   <groupId>commons-fileupload</groupId>\r\n   <artifactId>commons-fileupload</artifactId>\r\n   <version>1.3.1</version>\r\n </dependency>\r\n <dependency>\r\n   <groupId>commons-io</groupId>\r\n   <artifactId>commons-io</artifactId>\r\n   <version>2.4</version>\r\n </dependency>\r\n ```\r\n  2、spring-mvc.xml\r\n  ```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"\r\n                http://www.springframework.org/schema/beans\r\n                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\r\n                http://www.springframework.org/schema/context\r\n                http://www.springframework.org/schema/context/spring-context-3.1.xsd\r\n                http://www.springframework.org/schema/mvc\r\n                http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\" >\r\n    <!-- 启用SpringMVC的注解功能,它会自动注册HandlerMapping、HandlerAdapter、ExceptionResolver的相关实例 -->\r\n    <mvc:annotation-driven />\r\n    <!-- SpringMVC的扫描范围 -->\r\n    <context:component-scan base-package=\"com.liuyanzhao.blog.controller\" use-default-filters=\"false\">\r\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\r\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/>\r\n    </context:component-scan>\r\n    <!-- 用于返回json格式 -->\r\n    <bean id=\"mappingJacksonHttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\r\n        <property name=\"supportedMediaTypes\">\r\n            <list>\r\n                <value>application/x-www-form-urlencoded;charset=UTF-8</value>\r\n            </list>\r\n        </property>\r\n    </bean>\r\n    <!-- 完成请求和注解POJO的映射 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n        <property name=\"messageConverters\">\r\n            <list >\r\n                <ref bean=\"mappingJacksonHttpMessageConverter\" />\r\n            </list>\r\n        </property>\r\n    </bean>\r\n    <!-- 配置SpringMVC的视图解析器 -->\r\n    <!-- 其viewClass属性的默认值就是org.springframework.web.servlet.view.JstlView -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /> -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/views/\" />\r\n        <property name=\"suffix\" value=\".jsp\" />\r\n    </bean>\r\n    <!--文件上传-->\r\n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\r\n        <!--设置上传最大尺寸为50MB-->\r\n        <property name=\"maxUploadSize\" value=\"52428800\"/>\r\n        <property name=\"defaultEncoding\" value=\"UTF-8\"/>\r\n        <property name=\"resolveLazily\" value=\"true\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n上面是 spring-mvc.xml 所有的代码 一定要添加 文件上传 那块代码（50-55行） 然后 31-38 行的 对象转成JSON 也要正确     \r\n\r\n3、UploadFileController.java\r\n```\r\npackage com.liuyanzhao.blog.controller;\r\nimport com.liuyanzhao.blog.vo.ResultVO;\r\nimport com.liuyanzhao.blog.vo.UploadFileVO;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Calendar;\r\n@Controller\r\npublic class UploadFileController {\r\n    //上传文件\r\n    @RequestMapping(value = \"/uploadFile\",method = RequestMethod.POST)\r\n    @ResponseBody\r\n    public ResultVO uploadFile(@Param(\"file\")MultipartFile file) throws IOException {\r\n        //本地使用,上传位置\r\n        String rootPath =\"/Users/liuyanzhao/Documents/uploads/\";\r\n        //String rootPath =\"/www/uploads/\";\r\n        //文件的完整名称,如spring.jpeg\r\n        String filename = file.getOriginalFilename();\r\n        //文件名,如spring\r\n        String name = filename.substring(0,filename.indexOf(\".\"));\r\n        //文件后缀,如.jpeg\r\n        String suffix = filename.substring(filename.lastIndexOf(\".\"));\r\n        //创建年月文件夹\r\n        Calendar date = Calendar.getInstance();\r\n        File dateDirs = new File(date.get(Calendar.YEAR)\r\n                + File.separator + (date.get(Calendar.MONTH)+1));\r\n        //目标文件\r\n        File descFile = new File(rootPath+File.separator+dateDirs+File.separator+filename);\r\n        int i = 1;\r\n        //若文件存在重命名\r\n        String newFilename = filename;\r\n        while(descFile.exists()) {\r\n            newFilename = name+\"(\"+i+\")\"+suffix;\r\n            String parentPath = descFile.getParent();\r\n            descFile = new File(parentPath+File.separator+dateDirs+File.separator+newFilename);\r\n            i++;\r\n        }\r\n        //判断目标文件所在的目录是否存在\r\n        if(!descFile.getParentFile().exists()) {\r\n            //如果目标文件所在的目录不存在，则创建父目录\r\n            descFile.getParentFile().mkdirs();\r\n        }\r\n        //将内存中的数据写入磁盘\r\n        file.transferTo(descFile);\r\n        //完整的url\r\n        String fileUrl =  \"/uploads/\"+dateDirs+ \"/\"+newFilename;\r\n        ResultVO resultVO = new ResultVO();\r\n        resultVO.setCode(0);\r\n        resultVO.setMsg(\"成功\");\r\n        UploadFileVO uploadFileVO = new UploadFileVO();\r\n        uploadFileVO.setTitle(filename);\r\n        uploadFileVO.setUrl(fileUrl);\r\n        resultVO.setData(uploadFileVO);\r\n        return resultVO;\r\n    }\r\n}\r\n```\r\n  注意： ① 一定要加  @ResponseBody   注解，加了 @ResponseBody 注解，我们返回的 resultVO 对象会转成 JSON 返回前台。这个依赖于前面说的 spirng-mvc.xml 里的 JSON 配置 ② 返回给前台的 JSON 格式如下 所以我这里封装了对象 resultVO 和 uploadFileVO 具体类下面会给出 ③ 记得要修改第30行的本地路径，这个路径待会儿还要配静态资源映射   4、ResultVO.java 和 UploadFileVO.java ① ResultVO.java\r\n  ```\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:04\r\n */\r\npublic class ResultVO<T> {\r\n    //错误码\r\n    private Integer code;\r\n    //提示信息\r\n    private String msg;\r\n    //返回的具体内容\r\n    private T data;\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n    public void setMsg(String msg) {\r\n        this.msg = msg;\r\n    }\r\n    public T getData() {\r\n        return data;\r\n    }\r\n    public void setData(T data) {\r\n        this.data = data;\r\n    }\r\n}\r\n这里的 T 表示泛型 ② UploadFileVO.java\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:41\r\n */\r\npublic class UploadFileVO {\r\n    private String url;\r\n    private String title;\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n    public void setUrl(String url) {\r\n        this.url = url;\r\n    }\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n}\r\n```\r\n因为这里是上传图片，我们需要给前台返回返回一个 文件的URL，所以这里封装一个对象，用来拼接JSON。\r\n\r\n# 设置静态资源映射，用于显示图片\r\n我这里设置上传文件到 /Users/liuyanzhao/Documents/uploads 目录\r\n比如有一张图片的本地路径为\r\n\r\n/Users/liuyanzhao/Documents/uploads/2017/11/2017113021011541.jpg\r\n\r\n我们想让它能在服务器上访问，需要给 Tomcat 配置静态资源映射\r\n\r\n### 方法一、\r\n使用 IDE 配置，比如我使用的是 IntelliJ IDEA 可以在 Tomcat 的配置 Development 里，如图 \r\n![](/Blog/static/pic/1554800894813.jpg)\r\n\r\n### 方法二、\r\n如果你是直接启动本地的 Tomcat，而不是 IDE 的（不太记得 Eclipse 能不能直接设置），可以在 Tomcat 的目录下的 config/server.xml 里\r\n我的是\r\n`/Users/liuyanzhao/Documents/JavaStudy/tomcat/apache-tomcat-7.0.37/conf/server.xml`\r\n\r\n在最后的 </Host> 里添加\r\n```\r\n<!-- 增加的静态资源映射配置 -->\r\n<Context path=\"/uploads\" docBase=\"/Users/liuyanzhao/Documents/uploads\" reloadable=\"true\" crossContext=\"true\"></Context>\r\n```\r\n如图       \r\n![](/Blog/static/pic/1554800966634.jpg)\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本文介绍使用 SpringMVC + ajaxfileupload.js 实现 ajax 上传文件。 先看效果图<br><img src=\"/Blog/static/pic/1554800492432.gif\" alt=\"\"><br>  点击上传文件框，触发上传文件方法，然后后台返回图片的 url，进行显示。</p>\r\n<h1 id=\"h1-u524Du53F0u4EE3u7801\"><a name=\"前台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台代码</h1><p>1、add.jsp (或者 html 文件)</p>\r\n<pre><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; onchange=&quot;uploadImg()&quot;&gt;\r\n&lt;input type=&quot;hidden&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt;\r\n&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;avatarShow&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt;\r\n</code></pre><p>2、引入 jquery 和 ajaxfileupload.js</p>\r\n<pre><code>&lt;script src=&quot;${pageContext.request.contextPath}/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;${pageContext.request.contextPath}/static/js/ajaxfileupload.js&quot;&gt;&lt;/script&gt;\r\n</code></pre><p>这里给出 ajaxfileupload.js 下载地址，网上也有下载 这里有个坑，详情看这里 使用ajaxfileupload.js上传文件成功之后，没有执行success方法。</p>\r\n<pre><code>&lt;script&gt;\r\n    //ajax提交信息\r\n    function uploadImg() {\r\n        if($(&quot;#file&quot;).val() != &quot;&quot;) {\r\n            $.ajaxFileUpload({\r\n                type: &quot;POST&quot;,\r\n                url:&quot;${pageContext.request.contextPath}/uploadFile&quot;,\r\n                dataType: &quot;json&quot;,\r\n                fileElementId:&quot;file&quot;,  // 文件的id\r\n                success: function(d){\r\n                    if(d.code == 0) {\r\n                        //alert(&quot;上传成功&quot;);\r\n                        //图片显示\r\n                        $(&quot;#avatar&quot;).attr(&quot;value&quot;,d.data.url);\r\n                        $(&quot;#avatarShow&quot;).attr(&quot;src&quot;,d.data.url);\r\n                    }\r\n                },\r\n                error: function () {\r\n                    alert(&quot;上传失败&quot;);\r\n                },\r\n            });\r\n        } else {\r\n            alert(&quot;请先选择文件&quot;);\r\n        }\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre><p>需要放在 上面两个库的后面 注意： ① type 填 post ② 第8行的 dataType 是小写的 json，不要写成大写的啦 ③ 第9行的 fileElementId 填文件框的id ④ 先确保 url 没写错  </p>\r\n<h1 id=\"h1-u540Eu53F0u4EE3u7801\"><a name=\"后台代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后台代码</h1><p>1、给 maven 添加依赖 ①、首先需要导入 json 的依赖</p>\r\n<pre><code>&lt;!-- jackson --&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n    &lt;dependency&gt;\r\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\r\n      &lt;version&gt;2.5.0&lt;/version&gt;\r\n    &lt;/dependency&gt;\r\n</code></pre><p>  ②、然后需要上传文件的依赖</p>\r\n<pre><code>&lt;dependency&gt;\r\n   &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\r\n   &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\r\n   &lt;version&gt;1.3.1&lt;/version&gt;\r\n &lt;/dependency&gt;\r\n &lt;dependency&gt;\r\n   &lt;groupId&gt;commons-io&lt;/groupId&gt;\r\n   &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\r\n   &lt;version&gt;2.4&lt;/version&gt;\r\n &lt;/dependency&gt;\r\n</code></pre><p>  2、spring-mvc.xml</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xsi:schemaLocation=&quot;\r\n                http://www.springframework.org/schema/beans\r\n                http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\r\n                http://www.springframework.org/schema/context\r\n                http://www.springframework.org/schema/context/spring-context-3.1.xsd\r\n                http://www.springframework.org/schema/mvc\r\n                http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd&quot; &gt;\r\n    &lt;!-- 启用SpringMVC的注解功能,它会自动注册HandlerMapping、HandlerAdapter、ExceptionResolver的相关实例 --&gt;\r\n    &lt;mvc:annotation-driven /&gt;\r\n    &lt;!-- SpringMVC的扫描范围 --&gt;\r\n    &lt;context:component-scan base-package=&quot;com.liuyanzhao.blog.controller&quot; use-default-filters=&quot;false&quot;&gt;\r\n        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\r\n        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt;\r\n    &lt;/context:component-scan&gt;\r\n    &lt;!-- 用于返回json格式 --&gt;\r\n    &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;\r\n        &lt;property name=&quot;supportedMediaTypes&quot;&gt;\r\n            &lt;list&gt;\r\n                &lt;value&gt;application/x-www-form-urlencoded;charset=UTF-8&lt;/value&gt;\r\n            &lt;/list&gt;\r\n        &lt;/property&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!-- 完成请求和注解POJO的映射 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;\r\n        &lt;property name=&quot;messageConverters&quot;&gt;\r\n            &lt;list &gt;\r\n                &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt;\r\n            &lt;/list&gt;\r\n        &lt;/property&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!-- 配置SpringMVC的视图解析器 --&gt;\r\n    &lt;!-- 其viewClass属性的默认值就是org.springframework.web.servlet.view.JstlView --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n        &lt;!-- &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; --&gt;\r\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt;\r\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!--文件上传--&gt;\r\n    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\r\n        &lt;!--设置上传最大尺寸为50MB--&gt;\r\n        &lt;property name=&quot;maxUploadSize&quot; value=&quot;52428800&quot;/&gt;\r\n        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;\r\n        &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;\r\n    &lt;/bean&gt;\r\n&lt;/beans&gt;\r\n</code></pre><p>上面是 spring-mvc.xml 所有的代码 一定要添加 文件上传 那块代码（50-55行） 然后 31-38 行的 对象转成JSON 也要正确     </p>\r\n<p>3、UploadFileController.java</p>\r\n<pre><code>package com.liuyanzhao.blog.controller;\r\nimport com.liuyanzhao.blog.vo.ResultVO;\r\nimport com.liuyanzhao.blog.vo.UploadFileVO;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Calendar;\r\n@Controller\r\npublic class UploadFileController {\r\n    //上传文件\r\n    @RequestMapping(value = &quot;/uploadFile&quot;,method = RequestMethod.POST)\r\n    @ResponseBody\r\n    public ResultVO uploadFile(@Param(&quot;file&quot;)MultipartFile file) throws IOException {\r\n        //本地使用,上传位置\r\n        String rootPath =&quot;/Users/liuyanzhao/Documents/uploads/&quot;;\r\n        //String rootPath =&quot;/www/uploads/&quot;;\r\n        //文件的完整名称,如spring.jpeg\r\n        String filename = file.getOriginalFilename();\r\n        //文件名,如spring\r\n        String name = filename.substring(0,filename.indexOf(&quot;.&quot;));\r\n        //文件后缀,如.jpeg\r\n        String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;));\r\n        //创建年月文件夹\r\n        Calendar date = Calendar.getInstance();\r\n        File dateDirs = new File(date.get(Calendar.YEAR)\r\n                + File.separator + (date.get(Calendar.MONTH)+1));\r\n        //目标文件\r\n        File descFile = new File(rootPath+File.separator+dateDirs+File.separator+filename);\r\n        int i = 1;\r\n        //若文件存在重命名\r\n        String newFilename = filename;\r\n        while(descFile.exists()) {\r\n            newFilename = name+&quot;(&quot;+i+&quot;)&quot;+suffix;\r\n            String parentPath = descFile.getParent();\r\n            descFile = new File(parentPath+File.separator+dateDirs+File.separator+newFilename);\r\n            i++;\r\n        }\r\n        //判断目标文件所在的目录是否存在\r\n        if(!descFile.getParentFile().exists()) {\r\n            //如果目标文件所在的目录不存在，则创建父目录\r\n            descFile.getParentFile().mkdirs();\r\n        }\r\n        //将内存中的数据写入磁盘\r\n        file.transferTo(descFile);\r\n        //完整的url\r\n        String fileUrl =  &quot;/uploads/&quot;+dateDirs+ &quot;/&quot;+newFilename;\r\n        ResultVO resultVO = new ResultVO();\r\n        resultVO.setCode(0);\r\n        resultVO.setMsg(&quot;成功&quot;);\r\n        UploadFileVO uploadFileVO = new UploadFileVO();\r\n        uploadFileVO.setTitle(filename);\r\n        uploadFileVO.setUrl(fileUrl);\r\n        resultVO.setData(uploadFileVO);\r\n        return resultVO;\r\n    }\r\n}\r\n</code></pre><p>  注意： ① 一定要加  <a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a>   注解，加了 <a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a> 注解，我们返回的 resultVO 对象会转成 JSON 返回前台。这个依赖于前面说的 spirng-mvc.xml 里的 JSON 配置 ② 返回给前台的 JSON 格式如下 所以我这里封装了对象 resultVO 和 uploadFileVO 具体类下面会给出 ③ 记得要修改第30行的本地路径，这个路径待会儿还要配静态资源映射   4、ResultVO.java 和 UploadFileVO.java ① ResultVO.java</p>\r\n<pre><code>package com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:04\r\n */\r\npublic class ResultVO&lt;T&gt; {\r\n    //错误码\r\n    private Integer code;\r\n    //提示信息\r\n    private String msg;\r\n    //返回的具体内容\r\n    private T data;\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n    public void setMsg(String msg) {\r\n        this.msg = msg;\r\n    }\r\n    public T getData() {\r\n        return data;\r\n    }\r\n    public void setData(T data) {\r\n        this.data = data;\r\n    }\r\n}\r\n这里的 T 表示泛型 ② UploadFileVO.java\r\npackage com.liuyanzhao.blog.VO;\r\n/**\r\n * @author 言曌\r\n * @date 2017/11/30 下午7:41\r\n */\r\npublic class UploadFileVO {\r\n    private String url;\r\n    private String title;\r\n    public String getUrl() {\r\n        return url;\r\n    }\r\n    public void setUrl(String url) {\r\n        this.url = url;\r\n    }\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n}\r\n</code></pre><p>因为这里是上传图片，我们需要给前台返回返回一个 文件的URL，所以这里封装一个对象，用来拼接JSON。</p>\r\n<h1 id=\"h1--\"><a name=\"设置静态资源映射，用于显示图片\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置静态资源映射，用于显示图片</h1><p>我这里设置上传文件到 /Users/liuyanzhao/Documents/uploads 目录<br>比如有一张图片的本地路径为</p>\r\n<p>/Users/liuyanzhao/Documents/uploads/2017/11/2017113021011541.jpg</p>\r\n<p>我们想让它能在服务器上访问，需要给 Tomcat 配置静态资源映射</p>\r\n<h3 id=\"h3--\"><a name=\"方法一、\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法一、</h3><p>使用 IDE 配置，比如我使用的是 IntelliJ IDEA 可以在 Tomcat 的配置 Development 里，如图<br><img src=\"/Blog/static/pic/1554800894813.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3--\"><a name=\"方法二、\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法二、</h3><p>如果你是直接启动本地的 Tomcat，而不是 IDE 的（不太记得 Eclipse 能不能直接设置），可以在 Tomcat 的目录下的 config/server.xml 里<br>我的是<br><code>/Users/liuyanzhao/Documents/JavaStudy/tomcat/apache-tomcat-7.0.37/conf/server.xml</code></p>\r\n<p>在最后的 &lt;/Host&gt; 里添加</p>\r\n<pre><code>&lt;!-- 增加的静态资源映射配置 --&gt;\r\n&lt;Context path=&quot;/uploads&quot; docBase=&quot;/Users/liuyanzhao/Documents/uploads&quot; reloadable=&quot;true&quot; crossContext=&quot;true&quot;&gt;&lt;/Context&gt;\r\n</code></pre><p>如图<br><img src=\"/Blog/static/pic/1554800966634.jpg\" alt=\"\"></p>\r\n<hr>\r\n', '11', '0', '0', '1', '1', '2019-04-09 17:11:41', '2018-11-25 21:05:05', '\\static\\bgpic\\1554801100712.jpg');
INSERT INTO `article` VALUES ('33', '1', 'MySQL5.7.19Win10免安装配置+登录+问题解决', '# 前言\r\n最近需要用到MySQL，由于以前没有接触过，安装的时候也遇到了不少问题，花了不少时间幸好最后解决了，把自己的过程记录下来。\r\n\r\n# 主要的安装环境：\r\n1.Win10+64位\r\n2.MySQL5.7.19\r\n\r\n# 主要步骤：\r\nMySQL的安装有两种方法，一种是下载安装程序安装,这种比较推荐对安装路径没什么要求的，一般默认就安装在C盘里了，方法就是按照提示已知点NEXT，应该就可以安装了。我不想把软件安装在C盘，所以选择安装在D盘，开始也是用安装软件安装的，但是自定义安装路径就出了很多错误，一些路径啊什么的自己也不会改，最后也没安好。如果你是从来没有接触过MySQL的，想先下下来自己再学，又不想安在C盘里的话，就我自己的亲身经历，不推荐用这种方法。当然，你也可以自己去网上找教程去安（反正我没安好而且查了很久不知道怎么改）这种方法的SQL下载地址：\r\n本文推荐的是免安装配置，自己感觉相对简单。\r\n首先下载压缩包，下载地址：[https://dev.mysql.com/downloads/mysql/5.1.html#downloads](https://dev.mysql.com/downloads/mysql/5.1.html#downloads \"https://dev.mysql.com/downloads/mysql/5.1.html#downloads\")\r\n\r\n选择适合自己的压缩包（我的电脑是64位，所以选红圈里的）\r\n接着，点Download，下载，此时你可以选择下载到自定义的文件夹里（我下到了D盘）\r\n\r\n不用注册，直接点红圈里的就行。\r\n解压到你自定义的安装路径中，我同样选择安装在D盘里（如图）\r\n此时开始配置MySQL环境变量\r\n（1）点击“电脑”，右键\r\n\r\n（2）单击环境变量\r\n\r\n（3）点击系统变量，新建\r\n\r\n新增系统环境变量：\r\n变量名：MYSQL_HOME\r\n变量值：D：\\mysql-5.7.19-winx64\r\n接着再Path中添加：%MYSQL_HOME%\\bin \r\n（不要删除任何东西，只需再原来的后面加上分号，然后加上自己要配置的环境变量就可以了）\r\n\r\n改好后点确定-》确定\r\n\r\n7.在5.7.18版本以后的MySQL需要手动创建my.ini文件，然后放置到指定的目录下。\r\n（1）新建文本文档（即打开记事本）,然后改名字为my。将下面的内容粘贴进去记事本。\r\n```\r\n [client]\r\nport=3306\r\ndefault-character-set=utf8\r\n[mysqld]\r\nport=3306\r\ncharacter_set_server=utf8\r\nbasedir=%MYSQL_HOME%\r\ndatadir=%MYSQL_HOME%\\data\r\n[WinMySQLAdmin]\r\n%MYSQL_HOME%\\bin\\mysqld.exe\r\n```\r\n（2）粘贴后保存，修改文件后缀名为.ini   保存。\r\n\r\n（3）建立好my.ini文件后，将其复制粘贴到D：\\mysql-5.7.19-winx64\\bin，即放到mysql所在的bin目录下。\r\n\r\n使用管理员身份打开命令提示符，点击开始，然后输入cmd，鼠标右击cmd，选择以管理员身份运行。\r\n\r\n切换目录至mysql包所在的bin目录（例如本文中在D：\\mysql-5.7.19-winx64\\bin，就先输入D:，回车，再输入mysql-5.7.19-winx64\\bin）。然后输入 mysqld.exe -install\r\n\r\n执行命令后，提示：Service successfully installed. 表示安装成功.\r\n\r\n初始化mysql数据，并创建一个具有空密码的root用户，打开cmd执行如下命令：\r\n\r\n`   mysqld --initialize-insecure --user=mysql`\r\n\r\n   执行命令后，等一会后，系统会自动生成相应的 data 目录，并自动创建好空密码的 root 用户。此时表示初始化    成功。\r\n\r\n在cmd,也叫命令提示符中，输入下面的命令，启动mysql服务\r\n\r\n`     net start mysql`\r\n\r\n执行后，提示：\r\nMySQL服务正在启动\r\nMySQL服务已经启动成功\r\n注：要想登录使用 mysql，服务是必需要先启动的。以后也一样\r\n\r\n在服务启动后，因为刚创建的 root 用户是空密码的，因此需要先进行密码设定：\r\n\r\nmysqladmin -u root -p password 此处输入新密码\r\nEnter password: 此处输入旧密码\r\n\r\n执行完以上两条命令后，只要 Enter password: 后输入的旧密码正确，则 root 用户的新密码就算设定成功了。此后，要想登录 root 用户，则都需要使用新密码。\r\n注：刚创建的 root 用户是空密码的，因此，在第一次修改 root 用户的密码时，在 Enter password: 后面不需要输入任何密码，直接回车即可。\r\n\r\n此时安装登录完成，你可以对数据库进行操作，具体的本文不再讲解。\r\n\r\n关闭数据库\r\n\r\n         mysql> quit;\r\n         net stop mysql\r\n\r\n\r\n------------\r\n\r\n# 总结\r\n这就是安装Mysql的步骤，以前安装很麻烦，很容易出问题，浪费了很多时间在这个。\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>最近需要用到MySQL，由于以前没有接触过，安装的时候也遇到了不少问题，花了不少时间幸好最后解决了，把自己的过程记录下来。</p>\r\n<h1 id=\"h1--\"><a name=\"主要的安装环境：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主要的安装环境：</h1><p>1.Win10+64位<br>2.MySQL5.7.19</p>\r\n<h1 id=\"h1--\"><a name=\"主要步骤：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主要步骤：</h1><p>MySQL的安装有两种方法，一种是下载安装程序安装,这种比较推荐对安装路径没什么要求的，一般默认就安装在C盘里了，方法就是按照提示已知点NEXT，应该就可以安装了。我不想把软件安装在C盘，所以选择安装在D盘，开始也是用安装软件安装的，但是自定义安装路径就出了很多错误，一些路径啊什么的自己也不会改，最后也没安好。如果你是从来没有接触过MySQL的，想先下下来自己再学，又不想安在C盘里的话，就我自己的亲身经历，不推荐用这种方法。当然，你也可以自己去网上找教程去安（反正我没安好而且查了很久不知道怎么改）这种方法的SQL下载地址：<br>本文推荐的是免安装配置，自己感觉相对简单。<br>首先下载压缩包，下载地址：<a href=\"https://dev.mysql.com/downloads/mysql/5.1.html#downloads\" title=\"https://dev.mysql.com/downloads/mysql/5.1.html#downloads\">https://dev.mysql.com/downloads/mysql/5.1.html#downloads</a></p>\r\n<p>选择适合自己的压缩包（我的电脑是64位，所以选红圈里的）<br>接着，点Download，下载，此时你可以选择下载到自定义的文件夹里（我下到了D盘）</p>\r\n<p>不用注册，直接点红圈里的就行。<br>解压到你自定义的安装路径中，我同样选择安装在D盘里（如图）<br>此时开始配置MySQL环境变量<br>（1）点击“电脑”，右键</p>\r\n<p>（2）单击环境变量</p>\r\n<p>（3）点击系统变量，新建</p>\r\n<p>新增系统环境变量：<br>变量名：MYSQL_HOME<br>变量值：D：\\mysql-5.7.19-winx64<br>接着再Path中添加：%MYSQL_HOME%\\bin<br>（不要删除任何东西，只需再原来的后面加上分号，然后加上自己要配置的环境变量就可以了）</p>\r\n<p>改好后点确定-》确定</p>\r\n<p>7.在5.7.18版本以后的MySQL需要手动创建my.ini文件，然后放置到指定的目录下。<br>（1）新建文本文档（即打开记事本）,然后改名字为my。将下面的内容粘贴进去记事本。</p>\r\n<pre><code> [client]\r\nport=3306\r\ndefault-character-set=utf8\r\n[mysqld]\r\nport=3306\r\ncharacter_set_server=utf8\r\nbasedir=%MYSQL_HOME%\r\ndatadir=%MYSQL_HOME%\\data\r\n[WinMySQLAdmin]\r\n%MYSQL_HOME%\\bin\\mysqld.exe\r\n</code></pre><p>（2）粘贴后保存，修改文件后缀名为.ini   保存。</p>\r\n<p>（3）建立好my.ini文件后，将其复制粘贴到D：\\mysql-5.7.19-winx64\\bin，即放到mysql所在的bin目录下。</p>\r\n<p>使用管理员身份打开命令提示符，点击开始，然后输入cmd，鼠标右击cmd，选择以管理员身份运行。</p>\r\n<p>切换目录至mysql包所在的bin目录（例如本文中在D：\\mysql-5.7.19-winx64\\bin，就先输入D:，回车，再输入mysql-5.7.19-winx64\\bin）。然后输入 mysqld.exe -install</p>\r\n<p>执行命令后，提示：Service successfully installed. 表示安装成功.</p>\r\n<p>初始化mysql数据，并创建一个具有空密码的root用户，打开cmd执行如下命令：</p>\r\n<p><code>mysqld --initialize-insecure --user=mysql</code></p>\r\n<p>   执行命令后，等一会后，系统会自动生成相应的 data 目录，并自动创建好空密码的 root 用户。此时表示初始化    成功。</p>\r\n<p>在cmd,也叫命令提示符中，输入下面的命令，启动mysql服务</p>\r\n<p><code>net start mysql</code></p>\r\n<p>执行后，提示：<br>MySQL服务正在启动<br>MySQL服务已经启动成功<br>注：要想登录使用 mysql，服务是必需要先启动的。以后也一样</p>\r\n<p>在服务启动后，因为刚创建的 root 用户是空密码的，因此需要先进行密码设定：</p>\r\n<p>mysqladmin -u root -p password 此处输入新密码<br>Enter password: 此处输入旧密码</p>\r\n<p>执行完以上两条命令后，只要 Enter password: 后输入的旧密码正确，则 root 用户的新密码就算设定成功了。此后，要想登录 root 用户，则都需要使用新密码。<br>注：刚创建的 root 用户是空密码的，因此，在第一次修改 root 用户的密码时，在 Enter password: 后面不需要输入任何密码，直接回车即可。</p>\r\n<p>此时安装登录完成，你可以对数据库进行操作，具体的本文不再讲解。</p>\r\n<p>关闭数据库</p>\r\n<pre><code>     mysql&gt; quit;\r\n     net stop mysql\r\n</code></pre><hr>\r\n<h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><p>这就是安装Mysql的步骤，以前安装很麻烦，很容易出问题，浪费了很多时间在这个。</p>\r\n', '13', '0', '0', '1', '1', '2019-04-09 16:58:16', '2018-11-25 21:06:52', '\\static\\bgpic\\1554800086108.jpg');
INSERT INTO `article` VALUES ('34', '1', '用Markdown来写Wordpress文章', '# 安装Jetpack插件\r\nWordPress里要用MARKDOWN写东西要用到一个插件就是JP-MARKDOWN。这个是官方出的插件。而在国内网络貌似是无法链接到Wordpress官网的，翻墙之后安装好JP-MARKDOWN就行了。\r\n\r\n不过Wordpress的Markdown语法貌似跟正统的Markdown不太一样，而跟Markdown extra差不多，可以参见Markdown extra的文档。\r\nMARKDOWN_EXTRA\r\n\r\n不过大体上的效果还是差不多的。注意Markdown的语法，尤其是空格的使用，否则挺麻烦的。\r\n\r\n# 安装Crayon Syntax Highlighter插件\r\n这个是个语法高亮的插件，功能很强大，也完美兼容WordPress的Markdown。在下载安装Crayon Syntax Highlighter后，注意去插件设置处，将在 Crayon Syntax Highlighter 设置中不要勾选“捕获 反引号 为 标签”，否则会和Jetpack插件冲突。\r\n\r\n# 注意的点\r\n其他的东西都差不多，但是有一个点要注意，那就是代码的加入。若是在本地文本编辑器中，例如sublimetext里加入代码，我们通常在代码块的头尾加三个重音符，也就是数字键1左边那个键，一个点号。但是如果在WordPress文章里直接复制你在本地写的MARKDOWN文章，若不是从Crayon插件里加入代码，则一定要记得在代码段的前后加上pre标签，并且删去那三个重音符的代码标记符号，否则会出现代码错误。\r\n\r\n# 还有其他方式利用Markdown写文章\r\n我自己非常喜欢的一款文本编辑器Sublime Text在安装OmniMarkupPreviewer插件后，也能对Markdown有很好的支持，并且支持在浏览器中预览。在离线的情况下用Sublime Text来进行Markdown文章的书写体验还是相当棒的。可以尝试。另外t这个轻量级的文本编辑器在WINDOWS系统上的体验效果是相当棒的。并且支持VIM的大部分命令，也就是可以拿ST来练手VIM的操作。', '<h1 id=\"h1--jetpack-\"><a name=\"安装Jetpack插件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装Jetpack插件</h1><p>WordPress里要用MARKDOWN写东西要用到一个插件就是JP-MARKDOWN。这个是官方出的插件。而在国内网络貌似是无法链接到Wordpress官网的，翻墙之后安装好JP-MARKDOWN就行了。</p>\r\n<p>不过Wordpress的Markdown语法貌似跟正统的Markdown不太一样，而跟Markdown extra差不多，可以参见Markdown extra的文档。<br>MARKDOWN_EXTRA</p>\r\n<p>不过大体上的效果还是差不多的。注意Markdown的语法，尤其是空格的使用，否则挺麻烦的。</p>\r\n<h1 id=\"h1--crayon-syntax-highlighter-\"><a name=\"安装Crayon Syntax Highlighter插件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装Crayon Syntax Highlighter插件</h1><p>这个是个语法高亮的插件，功能很强大，也完美兼容WordPress的Markdown。在下载安装Crayon Syntax Highlighter后，注意去插件设置处，将在 Crayon Syntax Highlighter 设置中不要勾选“捕获 反引号 为 标签”，否则会和Jetpack插件冲突。</p>\r\n<h1 id=\"h1-u6CE8u610Fu7684u70B9\"><a name=\"注意的点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注意的点</h1><p>其他的东西都差不多，但是有一个点要注意，那就是代码的加入。若是在本地文本编辑器中，例如sublimetext里加入代码，我们通常在代码块的头尾加三个重音符，也就是数字键1左边那个键，一个点号。但是如果在WordPress文章里直接复制你在本地写的MARKDOWN文章，若不是从Crayon插件里加入代码，则一定要记得在代码段的前后加上pre标签，并且删去那三个重音符的代码标记符号，否则会出现代码错误。</p>\r\n<h1 id=\"h1--markdown-\"><a name=\"还有其他方式利用Markdown写文章\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>还有其他方式利用Markdown写文章</h1><p>我自己非常喜欢的一款文本编辑器Sublime Text在安装OmniMarkupPreviewer插件后，也能对Markdown有很好的支持，并且支持在浏览器中预览。在离线的情况下用Sublime Text来进行Markdown文章的书写体验还是相当棒的。可以尝试。另外t这个轻量级的文本编辑器在WINDOWS系统上的体验效果是相当棒的。并且支持VIM的大部分命令，也就是可以拿ST来练手VIM的操作。</p>\r\n', '8', '0', '0', '1', '1', '2019-04-09 16:48:51', '2018-11-25 21:09:53', '\\static\\bgpic\\1554799730777.jpg');
INSERT INTO `article` VALUES ('128', '1', '【NOTE】进程-线程-协程 关系与区别', '在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。\r\n# 进程\r\n一个进程好比是一个程序，它是 资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。\r\n\r\n电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。\r\n\r\n# 线程\r\n如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 「微进程」 。它是 程序执行过程中的最小单元 。\r\n\r\n一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：\r\n\r\n拖动进度条->画面更新->声音更新。你会明显感到画面和声音和进度条不同步。\r\n\r\n但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。\r\n\r\n# 协程\r\n协程在线程中实现调度。你可以理解为它是 「微线程」 。它的调度不来自于CPU，而是完全来自于用户控制（可以理解为用代码控制流程）。协程的执行效率非常高，它的切换不是线程切换，没有线程切换的开销。而且只要线程越多，协程的性能优势就越明显。协程不需要多线程的锁机制，只需要判断状态即可。不过协程本身无法利用多核CPU，因为它基于线程，而线程又依赖于进程。\r\n\r\n在JS里，常见的协程就是ES6的yield Generator或者ES7的async await。我们知道JS引擎是单线程的。所以在处理异步任务队列的时候，以往我们会陷入「回调金字塔」或者「回调地狱」。而有了协程之后我们可以在代码层面上来控制我们的程序。\r\n\r\n比如我们有这么一个需求，等两个请求都返回之后，用它们的返回值共同做些事。（此处不用Promise.all()来实现，不是说不行，而是为了更好地说明主题）\r\n```\r\nconst axios = require(\'axios\')\r\nconst co = require(\'co\')\r\nco(function* (){\r\n  const getData = yield axios.get(\'xxx\')\r\n  const postData = yield axios.post(\'xxx\')\r\n  console.log(getData, postData)\r\n})\r\n```\r\n\r\n# 总结\r\n可以说三者虽然是不同的东西，但是有着很密切的关系和类似的特性。它们的关系是从大到小，从上而下的。没有进程也就没有线程也就没有协程。总的来说，在多核处理器的情况下，多进程+多协程可以发挥最优的性能。\r\n\r\n# 参考文献\r\n1. [进程，线程，协程与并行，并发](http://https://www.jianshu.com/p/f11724034d50 \"进程，线程，协程与并行，并发\")\r\n2. [进程和线程、协程的区别](http://https://www.cnblogs.com/lxmhhy/p/6041001.html \"进程和线程、协程的区别\")\r\n3. [进程、线程和协程的比较](http://https://blog.csdn.net/blateyang/article/details/78088851 \"进程、线程和协程的比较\")\r\n4. [线程、进程与处理器](http://http://jsonliangyoujun.iteye.com/blog/2358274 \"线程、进程与处理器\")', '<p>在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。</p>\r\n<h1 id=\"h1-u8FDBu7A0B\"><a name=\"进程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>进程</h1><p>一个进程好比是一个程序，它是 资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p>\r\n<p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p>\r\n<h1 id=\"h1-u7EBFu7A0B\"><a name=\"线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程</h1><p>如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 「微进程」 。它是 程序执行过程中的最小单元 。</p>\r\n<p>一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：</p>\r\n<p>拖动进度条-&gt;画面更新-&gt;声音更新。你会明显感到画面和声音和进度条不同步。</p>\r\n<p>但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。</p>\r\n<h1 id=\"h1-u534Fu7A0B\"><a name=\"协程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>协程</h1><p>协程在线程中实现调度。你可以理解为它是 「微线程」 。它的调度不来自于CPU，而是完全来自于用户控制（可以理解为用代码控制流程）。协程的执行效率非常高，它的切换不是线程切换，没有线程切换的开销。而且只要线程越多，协程的性能优势就越明显。协程不需要多线程的锁机制，只需要判断状态即可。不过协程本身无法利用多核CPU，因为它基于线程，而线程又依赖于进程。</p>\r\n<p>在JS里，常见的协程就是ES6的yield Generator或者ES7的async await。我们知道JS引擎是单线程的。所以在处理异步任务队列的时候，以往我们会陷入「回调金字塔」或者「回调地狱」。而有了协程之后我们可以在代码层面上来控制我们的程序。</p>\r\n<p>比如我们有这么一个需求，等两个请求都返回之后，用它们的返回值共同做些事。（此处不用Promise.all()来实现，不是说不行，而是为了更好地说明主题）</p>\r\n<pre><code>const axios = require(&#39;axios&#39;)\r\nconst co = require(&#39;co&#39;)\r\nco(function* (){\r\n  const getData = yield axios.get(&#39;xxx&#39;)\r\n  const postData = yield axios.post(&#39;xxx&#39;)\r\n  console.log(getData, postData)\r\n})\r\n</code></pre><h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><p>可以说三者虽然是不同的东西，但是有着很密切的关系和类似的特性。它们的关系是从大到小，从上而下的。没有进程也就没有线程也就没有协程。总的来说，在多核处理器的情况下，多进程+多协程可以发挥最优的性能。</p>\r\n<h1 id=\"h1-u53C2u8003u6587u732E\"><a name=\"参考文献\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考文献</h1><ol>\r\n<li><a href=\"http://https://www.jianshu.com/p/f11724034d50\" title=\"进程，线程，协程与并行，并发\">进程，线程，协程与并行，并发</a></li><li><a href=\"http://https://www.cnblogs.com/lxmhhy/p/6041001.html\" title=\"进程和线程、协程的区别\">进程和线程、协程的区别</a></li><li><a href=\"http://https://blog.csdn.net/blateyang/article/details/78088851\" title=\"进程、线程和协程的比较\">进程、线程和协程的比较</a></li><li><a href=\"http://http://jsonliangyoujun.iteye.com/blog/2358274\" title=\"线程、进程与处理器\">线程、进程与处理器</a></li></ol>\r\n', '76', '0', '0', '1', '1', '2019-04-09 16:01:14', '2019-04-08 17:28:49', '\\static\\bgpic\\1554796874331.jpg');
INSERT INTO `article` VALUES ('129', '1', '浅谈前后端路由与前后端渲染', '最近经常会遇到有人问诸如类似下面的问题：\r\n为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了/的页面呢\r\n为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢\r\n啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢\r\n这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。\r\n老手可以绕道，去看些更有用的文章吧~\r\n\r\n# 什么是路由\r\n理解Web路由这篇文章讲得特别好了。\r\n```\r\n在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。\r\n```\r\n访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。\r\n\r\n# 从后端路由讲起\r\n在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入www.baidu.com到你看到网页这个过程中经历了什么」其实讲的也是这个道理。\r\n![](https://ws1.sinaimg.cn/large/8700af19ly1fproibqucxj20lu03odg9.jpg)\r\n在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个404状态码。这也是我们常说的404 NOT FOUND的由来。\r\n\r\n# URL与Methods\r\n如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：GET，POST，PUT，DELETE。\r\n>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 ——来自阮一峰《理解RESTful架构》\r\n\r\n虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以GET请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：\r\n`    router.post(\'/user/:id\', addUser)`\r\n假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：`http://xxx.com/user/123`的话是无法访问到的，也会返回一个404。因为后端只配了一个post方法的路由。如果要接受这个请求，那么必须有如下的路由：\r\n```router.get(\'/user/:id\', getUser) // 配置get路由\r\nrouter.post(\'/user/:id\', addUser)\r\n```\r\n# 后端路由与服务端渲染\r\n前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。\r\n\r\n如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的服务端渲染。\r\n\r\n服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。\r\n\r\nnode.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。\r\n\r\n不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。\r\n\r\n于是，我们开始进入了前端路由的时代。\r\n', '<p>最近经常会遇到有人问诸如类似下面的问题：<br>为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了/的页面呢<br>为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢<br>啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢<br>这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。<br>老手可以绕道，去看些更有用的文章吧~</p>\r\n<h1 id=\"h1-u4EC0u4E48u662Fu8DEFu7531\"><a name=\"什么是路由\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是路由</h1><p>理解Web路由这篇文章讲得特别好了。</p>\r\n<pre><code>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。\r\n</code></pre><p>访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。</p>\r\n<h1 id=\"h1-u4ECEu540Eu7AEFu8DEFu7531u8BB2u8D77\"><a name=\"从后端路由讲起\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从后端路由讲起</h1><p>在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入www.baidu.com到你看到网页这个过程中经历了什么」其实讲的也是这个道理。<br><img src=\"https://ws1.sinaimg.cn/large/8700af19ly1fproibqucxj20lu03odg9.jpg\" alt=\"\"><br>在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个404状态码。这也是我们常说的404 NOT FOUND的由来。</p>\r\n<h1 id=\"h1-url-methods\"><a name=\"URL与Methods\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>URL与Methods</h1><p>如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：GET，POST，PUT，DELETE。</p>\r\n<blockquote>\r\n<p>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 ——来自阮一峰《理解RESTful架构》</p>\r\n</blockquote>\r\n<p>虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以GET请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：<br><code>router.post(&#39;/user/:id&#39;, addUser)</code><br>假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：<code>http://xxx.com/user/123</code>的话是无法访问到的，也会返回一个404。因为后端只配了一个post方法的路由。如果要接受这个请求，那么必须有如下的路由：<br><code>router.get(&#39;/user/:id&#39;, getUser) // 配置get路由\r\nrouter.post(&#39;/user/:id&#39;, addUser)</code></p>\r\n<h1 id=\"h1-u540Eu7AEFu8DEFu7531u4E0Eu670Du52A1u7AEFu6E32u67D3\"><a name=\"后端路由与服务端渲染\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后端路由与服务端渲染</h1><p>前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。</p>\r\n<p>如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的服务端渲染。</p>\r\n<p>服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。</p>\r\n<p>node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。</p>\r\n<p>不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。</p>\r\n<p>于是，我们开始进入了前端路由的时代。</p>\r\n', '64', '2', '0', '1', '1', '2019-04-09 15:53:47', '2019-04-08 18:25:08', '\\static\\bgpic\\default.jpg');
INSERT INTO `article` VALUES ('113', '1', 'jQuery——删除 动态添加的元素的方法', '这两天在写JS，写一个遮罩层的时候发现了一个挺有意思的地方，就是直接运用jQ的$选择器的时候无法选择出动态创建的元素，因此也就无法做到删除这个动态添加的元素。然后找寻了各种方法，目前找到两种我觉得是挺好的解决办法。\r\n\r\n先看看我最初写的源代码\r\nHTML：只对一个DIV操作。查找按钮是用来做触发事件的。ID为mask的DIV是拿来当做遮罩层的。\r\n```\r\n<form class=\"search\">\r\n    <input type=\"text\" class=\"input-text\">\r\n    <input type=\"button\" class=\"input-button\" value=\"查找\">\r\n</form>\r\n<!-- <div id=\"mask\"></div> -->\r\n```\r\nCSS：\r\n```\r\n#mask{\r\n    position: absolute;\r\n    z-index: 100!important;\r\n    left: 0;\r\n    top: 0;\r\n    height: 1000px;\r\n    width: 100%;\r\n    background-color: #000;\r\n    opacity: 0.75;\r\n    filter: alpha(opacity = 75);\r\n}\r\n```\r\nJS:\r\n```\r\n$(document).ready(function () {\r\n    var _mask=$(\"<div id=\'mask\'></div>\");\r\n    // 点击按钮创建遮罩层\r\n    $(\".input-button\").click(function(){\r\n        $(_mask).appendTo(\"body\");      \r\n    });\r\n    // 点击遮罩层时删除遮罩层\r\n    $(\"#mask\").click(function(){\r\n        $(this).remove();\r\n    })\r\n});\r\n```\r\n以上代码看似能够实现我们的功能，但是实际上，当你点击遮罩层的时候，并不会删除遮罩层。因为遮罩层是我们点击查找按钮的时候动态创建的，所以直接靠$(\"#mask\")是无法选择出这种动态创建的元素的，自然也就没有作用了。\r\n\r\n# 第一种办法\r\n1. 函数封装\r\n我们可以将$(\"#mask\")这个选择器和动态创建元素的方法封装到一个函数中，然后在创建遮罩层的功能中引用这个函数，就能实现JQ识别出这个动态创建的元素。\r\n\r\n代码如下-JS：\r\n```\r\n// 将方法封装进一个叫做mask的函数中\r\nfunction mask(){\r\n    var _mask=$(\"<div id=\'mask\'></div>\");\r\n    $(_mask).appendTo(\"body\");\r\n    $(\"#mask\").click(function(){\r\n        $(this).remove();\r\n})\r\n};\r\n\r\n// 点击按钮创建遮罩层时调用这个函数\r\n$(\".input-button\").click(function(){\r\n    mask();\r\n    return false;\r\n});\r\n```\r\n# 第二种办法\r\n1. 使用jQuery的on()方法\r\njQuery在1.9版本之后取消了live()方法，所以对于原先用live()实现的方法现在改用on()方法。PS:同时on()方法还能够取代bind()、delegate()方法，也是官方推荐的一种方法。\r\n\r\n先说明一下live()方法。引用W3School的定义：\r\n\r\n>live() 方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。\r\n通过 live() 方法附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。\r\n\r\n注意第二句，\r\n\r\n>适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。\r\n\r\n因此live()方法可以用于选择动态创建的元素。在使用1.9以后版本的jQuery时，用on()方法来代替。\r\n\r\non()的用法：`$(selector).on(event,childSelector,data,function,map)`\r\n\r\n当其他选项没有参数时，我们可以忽略它们。这里我们关注三个选项。event：事件，childSelector：子选择器，function：功能。\r\n让on()产生live()相同的功能时，$(selector)里的selector要写成document,也就是绑定整个页面元素。这点很关键，通过页面元素去选择childSelector，即当页面元素的子元素有变化时，该方法能够实时选择出你想要的那个子元素，也就实现了动态选择。而event我们这里是点击，也就是click。至于function，看如下代码：\r\n```\r\nvar _mask=$(\"<div id=\'mask\'></div>\");\r\n// 点击按钮创建遮罩层\r\n$(\".input-button\").click(function(){\r\n    $(_mask).appendTo(\"body\");\r\n});\r\n// 点击遮罩层时删除遮罩层，注意采用了on()方法。\r\n$(document).on(\"click\",\"#mask\",function(){\r\n    $(this).remove();\r\n});\r\n```\r\n\r\n------------\r\n\r\n\r\n在写的时候我貌似发现原生JS由于获取元素id就是通过document.getElementById()的方法也就是直接从document里获取，貌似也不会出现选择不了动态创建元素的情况。这点以后仔细研究后再更新吧。', '<p>这两天在写JS，写一个遮罩层的时候发现了一个挺有意思的地方，就是直接运用jQ的$选择器的时候无法选择出动态创建的元素，因此也就无法做到删除这个动态添加的元素。然后找寻了各种方法，目前找到两种我觉得是挺好的解决办法。</p>\r\n<p>先看看我最初写的源代码<br>HTML：只对一个DIV操作。查找按钮是用来做触发事件的。ID为mask的DIV是拿来当做遮罩层的。</p>\r\n<pre><code>&lt;form class=&quot;search&quot;&gt;\r\n    &lt;input type=&quot;text&quot; class=&quot;input-text&quot;&gt;\r\n    &lt;input type=&quot;button&quot; class=&quot;input-button&quot; value=&quot;查找&quot;&gt;\r\n&lt;/form&gt;\r\n&lt;!-- &lt;div id=&quot;mask&quot;&gt;&lt;/div&gt; --&gt;\r\n</code></pre><p>CSS：</p>\r\n<pre><code>#mask{\r\n    position: absolute;\r\n    z-index: 100!important;\r\n    left: 0;\r\n    top: 0;\r\n    height: 1000px;\r\n    width: 100%;\r\n    background-color: #000;\r\n    opacity: 0.75;\r\n    filter: alpha(opacity = 75);\r\n}\r\n</code></pre><p>JS:</p>\r\n<pre><code>$(document).ready(function () {\r\n    var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n    // 点击按钮创建遮罩层\r\n    $(&quot;.input-button&quot;).click(function(){\r\n        $(_mask).appendTo(&quot;body&quot;);      \r\n    });\r\n    // 点击遮罩层时删除遮罩层\r\n    $(&quot;#mask&quot;).click(function(){\r\n        $(this).remove();\r\n    })\r\n});\r\n</code></pre><p>以上代码看似能够实现我们的功能，但是实际上，当你点击遮罩层的时候，并不会删除遮罩层。因为遮罩层是我们点击查找按钮的时候动态创建的，所以直接靠$(“#mask”)是无法选择出这种动态创建的元素的，自然也就没有作用了。</p>\r\n<h1 id=\"h1-u7B2Cu4E00u79CDu529Eu6CD5\"><a name=\"第一种办法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第一种办法</h1><ol>\r\n<li>函数封装<br>我们可以将$(“#mask”)这个选择器和动态创建元素的方法封装到一个函数中，然后在创建遮罩层的功能中引用这个函数，就能实现JQ识别出这个动态创建的元素。</li></ol>\r\n<p>代码如下-JS：</p>\r\n<pre><code>// 将方法封装进一个叫做mask的函数中\r\nfunction mask(){\r\n    var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n    $(_mask).appendTo(&quot;body&quot;);\r\n    $(&quot;#mask&quot;).click(function(){\r\n        $(this).remove();\r\n})\r\n};\r\n\r\n// 点击按钮创建遮罩层时调用这个函数\r\n$(&quot;.input-button&quot;).click(function(){\r\n    mask();\r\n    return false;\r\n});\r\n</code></pre><h1 id=\"h1-u7B2Cu4E8Cu79CDu529Eu6CD5\"><a name=\"第二种办法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二种办法</h1><ol>\r\n<li>使用jQuery的on()方法<br>jQuery在1.9版本之后取消了live()方法，所以对于原先用live()实现的方法现在改用on()方法。PS:同时on()方法还能够取代bind()、delegate()方法，也是官方推荐的一种方法。</li></ol>\r\n<p>先说明一下live()方法。引用W3School的定义：</p>\r\n<blockquote>\r\n<p>live() 方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。<br>通过 live() 方法附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。</p>\r\n</blockquote>\r\n<p>注意第二句，</p>\r\n<blockquote>\r\n<p>适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。</p>\r\n</blockquote>\r\n<p>因此live()方法可以用于选择动态创建的元素。在使用1.9以后版本的jQuery时，用on()方法来代替。</p>\r\n<p>on()的用法：<code>$(selector).on(event,childSelector,data,function,map)</code></p>\r\n<p>当其他选项没有参数时，我们可以忽略它们。这里我们关注三个选项。event：事件，childSelector：子选择器，function：功能。<br>让on()产生live()相同的功能时，$(selector)里的selector要写成document,也就是绑定整个页面元素。这点很关键，通过页面元素去选择childSelector，即当页面元素的子元素有变化时，该方法能够实时选择出你想要的那个子元素，也就实现了动态选择。而event我们这里是点击，也就是click。至于function，看如下代码：</p>\r\n<pre><code>var _mask=$(&quot;&lt;div id=&#39;mask&#39;&gt;&lt;/div&gt;&quot;);\r\n// 点击按钮创建遮罩层\r\n$(&quot;.input-button&quot;).click(function(){\r\n    $(_mask).appendTo(&quot;body&quot;);\r\n});\r\n// 点击遮罩层时删除遮罩层，注意采用了on()方法。\r\n$(document).on(&quot;click&quot;,&quot;#mask&quot;,function(){\r\n    $(this).remove();\r\n});\r\n</code></pre><hr>\r\n<p>在写的时候我貌似发现原生JS由于获取元素id就是通过document.getElementById()的方法也就是直接从document里获取，貌似也不会出现选择不了动态创建元素的情况。这点以后仔细研究后再更新吧。</p>\r\n', '21', '0', '0', '1', '1', '2019-04-16 14:06:13', '2019-04-03 13:55:13', '\\static\\bgpic\\1554801967666.jpg');
INSERT INTO `article` VALUES ('114', '1', '把你的github操作从ssh转成https', '从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。\r\n\r\n# 从ssh到https\r\n把原有项目从ssh的方式转成https其实很简单：\r\n```\r\n$ git remote set-url origin https://xxxxx#your https repo url\r\n```\r\n通过如下命令查看是否更改成功：\r\n```\r\n$ git remote -v\r\norigin https://github.com/xxx/xxx.github.io.git(fetch)\r\norigin https://github.com/xxx/xxx.github.io.git(push)\r\n```\r\n不过转成https之后会带来一个问题，那就是每次提交的时候都需要输入github的用户名密码。其实当初用ssh的方式除了安全之外很重要的一个原因就是不用每次都手动输入账号密码。不过其实https的方式也是可以实现的，只是需要一些额外配置。\r\n\r\n# 配置https免输入密码\r\ngit官方手册里有对于git-credential-store的描述。简单来说，就是将用户名和密码缓存在本地，每次提交的时候自动帮你填入用户名密码。\r\n\r\n>注意git版本需要在1.7以上\r\n\r\n开启也很简单：\r\n```\r\n$ git config --global credential.helper store\r\n```\r\n然后你对某个仓库第一次执行push操作的时候，会要求输入用户密码，之后就再也不用了：\r\n>官方示例\r\n\r\n```\r\n$ git config credential.helper store\r\n$ git push http://example.com/repo.git\r\nUsername: <type your username>\r\nPassword: <type your password>\r\n\r\n[several days later]\r\n$ git push http://example.com/repo.git\r\n[your credentials are used automatically]\r\n```\r\n通过store的方式会将你的账号密码以明文的形式存在~/.git-credentials文件里，大致长这样：\r\n```\r\n$ cat ~/.git-credentials\r\nhttps://username:password@github.com\r\n```\r\n如果你觉得这样不太安全，见下一章：\r\n\r\n# 提高安全性\r\n### ## Mac\r\n对于mac而言，可以将git默认的credential.helper指定成osxkeychain\r\n```\r\n$ git config --global credential.helper osxkeychain\r\n```\r\n然后可以通过\r\n```\r\n$ git config credential.helper\r\nosxkeychain\r\n```\r\n来查看是否指定成功了。之后用户名密码将会保存在系统自带的keychain access里。\r\n\r\n### Windows\r\n使用微软开发的[Git-Credential-Manager-for-Windows](https://github.com/Microsoft/Git-Credential-Manager-for-Windows \"Git-Credential-Manager-for-Windows\")\r\n\r\n最新版下载地址：[https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest](https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest \"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest\")\r\n\r\n安装之后，在控制台里输入：\r\n```\r\ngit config --global credential.helper manager\r\n```\r\n之后还是一样的，某个项目里输入用户名密码之后，以后就再也不用输入了。你可以在管理网络密码里找到你的用户密码——其实不是密码，而是token了，因为Git-Credential-Manager-for-Windows它会自动调用github的api生成Personal access tokens，你可以在你的github的Personal settings里找到它。所以安全性还是有保障的！\r\n\r\n# 总结\r\n如果你已经无法用ssh的方式连接github的话，不妨试试https的方式。至少目前来说还是有效的，而且配置也不难~Happy coding again！', '<p>从10月24日开始，由于总所周知的原因，某些地区一些运营商的网络环境下已经无法通过ssh的方式对一些国外服务器进行操作。很不幸github也因此被误杀。这对于广大程序猿来说，简直是一大噩耗。不过我发现通过https的方式还是可以对github进行操作的。毕竟技术是无罪的，不管怎么样，github总是要用的。所以可以将现有的ssh方式改成https。</p>\r\n<h1 id=\"h1--ssh-https\"><a name=\"从ssh到https\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从ssh到https</h1><p>把原有项目从ssh的方式转成https其实很简单：</p>\r\n<pre><code>$ git remote set-url origin https://xxxxx#your https repo url\r\n</code></pre><p>通过如下命令查看是否更改成功：</p>\r\n<pre><code>$ git remote -v\r\norigin https://github.com/xxx/xxx.github.io.git(fetch)\r\norigin https://github.com/xxx/xxx.github.io.git(push)\r\n</code></pre><p>不过转成https之后会带来一个问题，那就是每次提交的时候都需要输入github的用户名密码。其实当初用ssh的方式除了安全之外很重要的一个原因就是不用每次都手动输入账号密码。不过其实https的方式也是可以实现的，只是需要一些额外配置。</p>\r\n<h1 id=\"h1--https-\"><a name=\"配置https免输入密码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置https免输入密码</h1><p>git官方手册里有对于git-credential-store的描述。简单来说，就是将用户名和密码缓存在本地，每次提交的时候自动帮你填入用户名密码。</p>\r\n<blockquote>\r\n<p>注意git版本需要在1.7以上</p>\r\n</blockquote>\r\n<p>开启也很简单：</p>\r\n<pre><code>$ git config --global credential.helper store\r\n</code></pre><p>然后你对某个仓库第一次执行push操作的时候，会要求输入用户密码，之后就再也不用了：</p>\r\n<blockquote>\r\n<p>官方示例</p>\r\n</blockquote>\r\n<pre><code>$ git config credential.helper store\r\n$ git push http://example.com/repo.git\r\nUsername: &lt;type your username&gt;\r\nPassword: &lt;type your password&gt;\r\n\r\n[several days later]\r\n$ git push http://example.com/repo.git\r\n[your credentials are used automatically]\r\n</code></pre><p>通过store的方式会将你的账号密码以明文的形式存在~/.git-credentials文件里，大致长这样：</p>\r\n<pre><code>$ cat ~/.git-credentials\r\nhttps://username:password@github.com\r\n</code></pre><p>如果你觉得这样不太安全，见下一章：</p>\r\n<h1 id=\"h1-u63D0u9AD8u5B89u5168u6027\"><a name=\"提高安全性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提高安全性</h1><h3 id=\"h3--mac\"><a name=\"## Mac\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>## Mac</h3><p>对于mac而言，可以将git默认的credential.helper指定成osxkeychain</p>\r\n<pre><code>$ git config --global credential.helper osxkeychain\r\n</code></pre><p>然后可以通过</p>\r\n<pre><code>$ git config credential.helper\r\nosxkeychain\r\n</code></pre><p>来查看是否指定成功了。之后用户名密码将会保存在系统自带的keychain access里。</p>\r\n<h3 id=\"h3-windows\"><a name=\"Windows\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Windows</h3><p>使用微软开发的<a href=\"https://github.com/Microsoft/Git-Credential-Manager-for-Windows\" title=\"Git-Credential-Manager-for-Windows\">Git-Credential-Manager-for-Windows</a></p>\r\n<p>最新版下载地址：<a href=\"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest\" title=\"https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest\">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest</a></p>\r\n<p>安装之后，在控制台里输入：</p>\r\n<pre><code>git config --global credential.helper manager\r\n</code></pre><p>之后还是一样的，某个项目里输入用户名密码之后，以后就再也不用输入了。你可以在管理网络密码里找到你的用户密码——其实不是密码，而是token了，因为Git-Credential-Manager-for-Windows它会自动调用github的api生成Personal access tokens，你可以在你的github的Personal settings里找到它。所以安全性还是有保障的！</p>\r\n<h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><p>如果你已经无法用ssh的方式连接github的话，不妨试试https的方式。至少目前来说还是有效的，而且配置也不难~Happy coding again！</p>\r\n', '27', '0', '0', '1', '0', '2019-04-17 17:01:41', '2019-04-03 14:22:13', '\\static\\bgpic\\1555395085153.jpg');
INSERT INTO `article` VALUES ('131', '1', '一周一部好电影V【WEEK210 网络迷踪】', '# 2018-11-11 WEEK210 网络迷踪\r\n网络迷踪——————————————Searching\r\n![](/Blog/static/pic/1554814882971.jpg)\r\n1. 导演：阿尼什·查甘蒂\r\n2. 主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·\r\n3. 比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔\r\n4. 片长：102分钟\r\n5. 影 片类型：剧情/悬疑/惊悚\r\n6. 豆 瓣评分：8.7/10(from85,981users)\r\n7. IMDB评分：7.8/10(from38,178users)\r\n\r\nHi，各位好久不见！（最近在忙毕设开题的事，所以一直没办法按期完成推送。等忙过这一段就能大致恢复正常。）这部电影可以说是小成本制作的典范之作了。全片很有意思，大部分用的镜头来自手机、电脑的前置摄像头，然后配合电脑、手机屏幕的聊天记录、网页记录等来描述故事、展现角色心理状态。很多时候刚敲完的文字，然后想了想又删掉的光标；在屏幕前停留的视线等等都会让你身临其境——因为这些场景在我们当今的生活中，真的司空见惯。\r\n\r\n可以说手机和电脑加上互联网已经占据了很多人一天的大部分。本片也聚焦在当前的网络环境下的人与人之间，父母和孩子之间的关系。我们经常会对父母隐藏自己的某一面，而在互联网上却又是另一副的面孔。所以很多时候本该最了解我们的人，却成了最熟悉的陌生人。当然，意外的惊喜是本片还加入了很不错的悬疑元素，真相大白的那刻，总算把你觉得不对劲的地方说了出来，但是却让你依然感觉很过瘾。好电影，值得一看！\r\n\r\n------------\r\n\r\n# 2018-09-16 WEEK207 走到尽头\r\n![网络密宗](https://img.piegg.cn/week207.jpg?imgslim)\r\n1. 导演：金成勋\r\n2. 主演：李善均/赵震雄/郑满植/申东美/申正根/朴宝剑\r\n3. 片长：111分钟\r\n4. 影 片类型：动作/惊悚/犯罪\r\n5. 豆 瓣评分：7.8/10(from41,868users)\r\n6. IMDB评分：7.2/10(from7,509users)\r\n\r\nHi，各位好久不见！本周给大家推荐的是一部来自韩国的《走到尽头》。这部电影我在3年前曾看过一次，不过最近重新又看了一遍依然感觉十分不错。\r\n\r\n从影片一开始就开始就把观众带入非常紧张、刺激的情节，让人不由自主地为主角捏一把汗。而后的矛盾冲突又依然保持着高度的紧张和不突兀的幽默镜头。而随着剧情的推进，不断地反转也是让人看得很是过瘾。可以说是不停地用新的错误掩盖旧的错误。我想虽然电影有所夸张，但是现实中的我们却总会有类似的时刻。环环相扣的剧情在影片的最后达到高潮。开放式的结局也能让你思考良多。而比起我们的电影结局大多是阳光美好而言，这部电影的结局可以说带着一些黑色气息了。好电影，值得一看！\r\n\r\n------------\r\n# 2018-09-09 WEEK206 碟中谍6：全面瓦解\r\n![](https://img.piegg.cn/week206.jpg?imgslim)\r\n1. 导演：克里斯托弗·麦奎里\r\n2. 主演：汤姆·克鲁斯/亨利·卡维尔/文·瑞姆斯/西蒙·佩吉/丽贝卡·弗格森/西恩·哈里斯/安吉拉·贝塞特/凡妮莎·柯比/米歇尔·莫纳汉/韦斯·本特利/费雷德里克·施密特/亚历克·鲍德温/杨亮/克里斯托弗·琼勒/沃尔夫·布利策/拉斐尔·琼勒/安德鲁·卡扎纳夫·平/克里斯多夫·德·舒瓦西/拉裴尔·德普雷/让·巴普蒂斯特·菲永/马克斯·盖勒/奥利维尔·体班德/亚历山大·普尔/阿利克斯·贝纳泽什/乔伊·安沙/维利贝·托皮奇/格雷厄姆·福克斯/卡斯珀·菲利普森/菲恩·乔利/鲁斯·贝恩/奈杰尔·艾伦\r\n3. 片长：147分钟\r\n4. 影 片类型：动作/惊悚/冒险\r\n5. 豆 瓣评分：8.3/10(from164,538users)\r\n6. IMDB评分：8.1/10(from118,713users)\r\n\r\nHi，各位好久不见！本周给大家推荐的是一部最近正在热映的电影《碟中谍6：全面瓦解》。动作片系列，我觉得如今只有《速度与激情》系列能与《碟中谍》系列比拼了。\r\n\r\n阿汤哥依然是拼命三郎。本片全程无尿点。虽然剧情依然是跟核弹有关（哈哈）。不过不管是跳伞、飙车、开飞机甚至是「屋顶跑酷」都让人看得热血沸腾。22年了，阿汤哥依然是那个阿汤哥，不过当年看他电影的人已经长大了。熟悉的片头曲，琳琅满目的「黑科技」，剧情也是不停地反转反转。整部电影几乎一直处于神经紧绷的状态，让人看了大呼过瘾！\r\n\r\n不知道还能再看到阿汤哥的碟中谍多少次，这部好电影，我想你一定要去看看。\r\n\r\n------------\r\n# 2018-07-08 WEEK202 我不是药神\r\n我不是药神——————————————我不是药神\r\n![](https://img.piegg.cn/week202.jpg?imgslim)\r\n1. 导演：文牧野\r\n2. 主演：徐峥/王传君/周一围/谭卓/章宇/杨新鸣/王佳佳/王砚辉/贾晨飞/龚蓓苾/宁浩/李乃文\r\n3. 片长：117分钟\r\n4. 影 片类型：剧情/喜剧\r\n5. 豆 瓣评分：9.0/10(from350,132users)\r\n6. IMDB评分：8.3/10(from372users)\r\n\r\nHi，各位好久不见！本周给大家推荐的是刚上映的大热门《我不是药神》。其实光看名字和海报的时候，我以为只是徐峥的一部常规喜剧电影。然而自从点映以来就有不少朋友给我推荐。于是今天也去电影院看了，发现确实值得上豆瓣9.0的分数。「我们也拍出了韩国那样的电影」。这是我看完感慨最深的一点。\r\n\r\n在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影，真的非常不容易。其实从前年的《湄公河行动》、去年的《战狼2》、今年的《红海行动》之后，我很害怕我们国家以后的「好」电影都只能是这类主旋律的动作片了。我们有《心迷宫》、《暴裂无声》等质量上乘的悬疑电影，也有逗男女老少开心一笑的《泰囧》、《夏洛特烦恼》等优质喜剧片等等。但是我们缺的是直击社会问题，挖掘人性的剧情电影。我们少了多少《辩护人》、少了多少未见的《熔炉》、少了多少难得的《Taxi Driver》。今天一部《我不是药神》让我看到了中国电影的未来还是有希望的。这部基于真实事件改编的电影，从影片一开始就会让你有种深深代入感——因为你也是千千万万中国人之一，这就会是发生在你身边的事。\r\n\r\n不管是配乐、剪辑还是情节的把控，导演和主演们都让我们感到了深深的负责和认真。该给的镜头一个不少，该有的细节一个不缺，该哭的泪点一个不落。你知道这将是中国电影的一个里程碑式的电影么，这么棒的电影真的值得你去一看。\r\n\r\n------------\r\n# 2018-06-13 WEEK200 燃烧\r\n![](https://img.piegg.cn/week200.png?imgslim)\r\n1. 导演：李沧东\r\n2. 主演：刘亚仁/史蒂文·元/全钟瑞/金秀京/崔承浩/玉子妍\r\n3. 片长：148分钟\r\n4. 影 片类型：剧情/悬疑\r\n5. 豆 瓣评分：8.0/10(from23,263users)\r\n6. IMDB评分：7.9/10(from418users)\r\n\r\nHi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。改编自村上春树的《烧仓房》，不过导演也为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢，很多细节是慢慢地又完整地展现在你面前。而电影里最让人困惑，或者最烧脑，或者说加入了作者最深入的思考的部分，却又是那些可有可无的「线索」。它们有些到最后都没有得到导演给出的解释。开放式的结局，甚至开放式的剧情都是这部电影非常让人难以缓过神来的地方。而平淡地讲述故事的同时，也有着「最美之舞」的唯美画面。\r\n\r\n聚焦着当下韩国年轻人的痛点，在讲述一场可疑的案件的同时，又让你不得不思考，自己活着是一个「little hunger」还是一个「greate hunger」。而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看。\r\n\r\n------------\r\n\r\n\r\n\r\n', '<h1 id=\"h1-2018-11-11-week210-\"><a name=\"2018-11-11 WEEK210 网络迷踪\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2018-11-11 WEEK210 网络迷踪</h1><p>网络迷踪——————————————Searching<br><img src=\"/Blog/static/pic/1554814882971.jpg\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：阿尼什·查甘蒂</li><li>主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·</li><li>比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔</li><li>片长：102分钟</li><li>影 片类型：剧情/悬疑/惊悚</li><li>豆 瓣评分：8.7/10(from85,981users)</li><li>IMDB评分：7.8/10(from38,178users)</li></ol>\r\n<p>Hi，各位好久不见！（最近在忙毕设开题的事，所以一直没办法按期完成推送。等忙过这一段就能大致恢复正常。）这部电影可以说是小成本制作的典范之作了。全片很有意思，大部分用的镜头来自手机、电脑的前置摄像头，然后配合电脑、手机屏幕的聊天记录、网页记录等来描述故事、展现角色心理状态。很多时候刚敲完的文字，然后想了想又删掉的光标；在屏幕前停留的视线等等都会让你身临其境——因为这些场景在我们当今的生活中，真的司空见惯。</p>\r\n<p>可以说手机和电脑加上互联网已经占据了很多人一天的大部分。本片也聚焦在当前的网络环境下的人与人之间，父母和孩子之间的关系。我们经常会对父母隐藏自己的某一面，而在互联网上却又是另一副的面孔。所以很多时候本该最了解我们的人，却成了最熟悉的陌生人。当然，意外的惊喜是本片还加入了很不错的悬疑元素，真相大白的那刻，总算把你觉得不对劲的地方说了出来，但是却让你依然感觉很过瘾。好电影，值得一看！</p>\r\n<hr>\r\n<h1 id=\"h1-2018-09-16-week207-\"><a name=\"2018-09-16 WEEK207 走到尽头\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2018-09-16 WEEK207 走到尽头</h1><p><img src=\"https://img.piegg.cn/week207.jpg?imgslim\" alt=\"网络密宗\"></p>\r\n<ol>\r\n<li>导演：金成勋</li><li>主演：李善均/赵震雄/郑满植/申东美/申正根/朴宝剑</li><li>片长：111分钟</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from41,868users)</li><li>IMDB评分：7.2/10(from7,509users)</li></ol>\r\n<p>Hi，各位好久不见！本周给大家推荐的是一部来自韩国的《走到尽头》。这部电影我在3年前曾看过一次，不过最近重新又看了一遍依然感觉十分不错。</p>\r\n<p>从影片一开始就开始就把观众带入非常紧张、刺激的情节，让人不由自主地为主角捏一把汗。而后的矛盾冲突又依然保持着高度的紧张和不突兀的幽默镜头。而随着剧情的推进，不断地反转也是让人看得很是过瘾。可以说是不停地用新的错误掩盖旧的错误。我想虽然电影有所夸张，但是现实中的我们却总会有类似的时刻。环环相扣的剧情在影片的最后达到高潮。开放式的结局也能让你思考良多。而比起我们的电影结局大多是阳光美好而言，这部电影的结局可以说带着一些黑色气息了。好电影，值得一看！</p>\r\n<hr>\r\n<h1 id=\"h1-2018-09-09-week206-6-\"><a name=\"2018-09-09 WEEK206 碟中谍6：全面瓦解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2018-09-09 WEEK206 碟中谍6：全面瓦解</h1><p><img src=\"https://img.piegg.cn/week206.jpg?imgslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：克里斯托弗·麦奎里</li><li>主演：汤姆·克鲁斯/亨利·卡维尔/文·瑞姆斯/西蒙·佩吉/丽贝卡·弗格森/西恩·哈里斯/安吉拉·贝塞特/凡妮莎·柯比/米歇尔·莫纳汉/韦斯·本特利/费雷德里克·施密特/亚历克·鲍德温/杨亮/克里斯托弗·琼勒/沃尔夫·布利策/拉斐尔·琼勒/安德鲁·卡扎纳夫·平/克里斯多夫·德·舒瓦西/拉裴尔·德普雷/让·巴普蒂斯特·菲永/马克斯·盖勒/奥利维尔·体班德/亚历山大·普尔/阿利克斯·贝纳泽什/乔伊·安沙/维利贝·托皮奇/格雷厄姆·福克斯/卡斯珀·菲利普森/菲恩·乔利/鲁斯·贝恩/奈杰尔·艾伦</li><li>片长：147分钟</li><li>影 片类型：动作/惊悚/冒险</li><li>豆 瓣评分：8.3/10(from164,538users)</li><li>IMDB评分：8.1/10(from118,713users)</li></ol>\r\n<p>Hi，各位好久不见！本周给大家推荐的是一部最近正在热映的电影《碟中谍6：全面瓦解》。动作片系列，我觉得如今只有《速度与激情》系列能与《碟中谍》系列比拼了。</p>\r\n<p>阿汤哥依然是拼命三郎。本片全程无尿点。虽然剧情依然是跟核弹有关（哈哈）。不过不管是跳伞、飙车、开飞机甚至是「屋顶跑酷」都让人看得热血沸腾。22年了，阿汤哥依然是那个阿汤哥，不过当年看他电影的人已经长大了。熟悉的片头曲，琳琅满目的「黑科技」，剧情也是不停地反转反转。整部电影几乎一直处于神经紧绷的状态，让人看了大呼过瘾！</p>\r\n<p>不知道还能再看到阿汤哥的碟中谍多少次，这部好电影，我想你一定要去看看。</p>\r\n<hr>\r\n<h1 id=\"h1-2018-07-08-week202-\"><a name=\"2018-07-08 WEEK202 我不是药神\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2018-07-08 WEEK202 我不是药神</h1><p>我不是药神——————————————我不是药神<br><img src=\"https://img.piegg.cn/week202.jpg?imgslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：文牧野</li><li>主演：徐峥/王传君/周一围/谭卓/章宇/杨新鸣/王佳佳/王砚辉/贾晨飞/龚蓓苾/宁浩/李乃文</li><li>片长：117分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：9.0/10(from350,132users)</li><li>IMDB评分：8.3/10(from372users)</li></ol>\r\n<p>Hi，各位好久不见！本周给大家推荐的是刚上映的大热门《我不是药神》。其实光看名字和海报的时候，我以为只是徐峥的一部常规喜剧电影。然而自从点映以来就有不少朋友给我推荐。于是今天也去电影院看了，发现确实值得上豆瓣9.0的分数。「我们也拍出了韩国那样的电影」。这是我看完感慨最深的一点。</p>\r\n<p>在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影，真的非常不容易。其实从前年的《湄公河行动》、去年的《战狼2》、今年的《红海行动》之后，我很害怕我们国家以后的「好」电影都只能是这类主旋律的动作片了。我们有《心迷宫》、《暴裂无声》等质量上乘的悬疑电影，也有逗男女老少开心一笑的《泰囧》、《夏洛特烦恼》等优质喜剧片等等。但是我们缺的是直击社会问题，挖掘人性的剧情电影。我们少了多少《辩护人》、少了多少未见的《熔炉》、少了多少难得的《Taxi Driver》。今天一部《我不是药神》让我看到了中国电影的未来还是有希望的。这部基于真实事件改编的电影，从影片一开始就会让你有种深深代入感——因为你也是千千万万中国人之一，这就会是发生在你身边的事。</p>\r\n<p>不管是配乐、剪辑还是情节的把控，导演和主演们都让我们感到了深深的负责和认真。该给的镜头一个不少，该有的细节一个不缺，该哭的泪点一个不落。你知道这将是中国电影的一个里程碑式的电影么，这么棒的电影真的值得你去一看。</p>\r\n<hr>\r\n<h1 id=\"h1-2018-06-13-week200-\"><a name=\"2018-06-13 WEEK200 燃烧\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2018-06-13 WEEK200 燃烧</h1><p><img src=\"https://img.piegg.cn/week200.png?imgslim\" alt=\"\"></p>\r\n<ol>\r\n<li>导演：李沧东</li><li>主演：刘亚仁/史蒂文·元/全钟瑞/金秀京/崔承浩/玉子妍</li><li>片长：148分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：8.0/10(from23,263users)</li><li>IMDB评分：7.9/10(from418users)</li></ol>\r\n<p>Hi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。改编自村上春树的《烧仓房》，不过导演也为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢，很多细节是慢慢地又完整地展现在你面前。而电影里最让人困惑，或者最烧脑，或者说加入了作者最深入的思考的部分，却又是那些可有可无的「线索」。它们有些到最后都没有得到导演给出的解释。开放式的结局，甚至开放式的剧情都是这部电影非常让人难以缓过神来的地方。而平淡地讲述故事的同时，也有着「最美之舞」的唯美画面。</p>\r\n<p>聚焦着当下韩国年轻人的痛点，在讲述一场可疑的案件的同时，又让你不得不思考，自己活着是一个「little hunger」还是一个「greate hunger」。而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看。</p>\r\n<hr>\r\n', '325', '6', '0', '1', '1', '2019-04-16 01:10:39', '2019-04-09 14:21:25', '\\static\\bgpic\\1555348239502.jpg');

-- ----------------------------
-- Table structure for article_category_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_category_ref`;
CREATE TABLE `article_category_ref` (
  `article_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_category_ref
-- ----------------------------
INSERT INTO `article_category_ref` VALUES ('129', '1');
INSERT INTO `article_category_ref` VALUES ('129', '2');
INSERT INTO `article_category_ref` VALUES ('128', '1');
INSERT INTO `article_category_ref` VALUES ('128', '2');
INSERT INTO `article_category_ref` VALUES ('128', '4');
INSERT INTO `article_category_ref` VALUES ('34', '54');
INSERT INTO `article_category_ref` VALUES ('33', '10');
INSERT INTO `article_category_ref` VALUES ('33', '13');
INSERT INTO `article_category_ref` VALUES ('32', '1');
INSERT INTO `article_category_ref` VALUES ('32', '2');
INSERT INTO `article_category_ref` VALUES ('32', '8');
INSERT INTO `article_category_ref` VALUES ('31', '54');
INSERT INTO `article_category_ref` VALUES ('30', '55');
INSERT INTO `article_category_ref` VALUES ('28', '56');
INSERT INTO `article_category_ref` VALUES ('27', '57');
INSERT INTO `article_category_ref` VALUES ('27', '58');
INSERT INTO `article_category_ref` VALUES ('26', '54');
INSERT INTO `article_category_ref` VALUES ('29', '15');
INSERT INTO `article_category_ref` VALUES ('29', '54');
INSERT INTO `article_category_ref` VALUES ('16', '1');
INSERT INTO `article_category_ref` VALUES ('16', '5');
INSERT INTO `article_category_ref` VALUES ('17', '1');
INSERT INTO `article_category_ref` VALUES ('17', '4');
INSERT INTO `article_category_ref` VALUES ('126', '16');
INSERT INTO `article_category_ref` VALUES ('126', '54');
INSERT INTO `article_category_ref` VALUES ('131', '15');
INSERT INTO `article_category_ref` VALUES ('131', '16');
INSERT INTO `article_category_ref` VALUES ('130', '1');
INSERT INTO `article_category_ref` VALUES ('130', '8');
INSERT INTO `article_category_ref` VALUES ('113', '1');
INSERT INTO `article_category_ref` VALUES ('113', '8');
INSERT INTO `article_category_ref` VALUES ('114', '54');

-- ----------------------------
-- Table structure for article_tag_ref
-- ----------------------------
DROP TABLE IF EXISTS `article_tag_ref`;
CREATE TABLE `article_tag_ref` (
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`article_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_tag_ref
-- ----------------------------
INSERT INTO `article_tag_ref` VALUES ('16', '1');
INSERT INTO `article_tag_ref` VALUES ('16', '17');
INSERT INTO `article_tag_ref` VALUES ('16', '52');
INSERT INTO `article_tag_ref` VALUES ('17', '1');
INSERT INTO `article_tag_ref` VALUES ('17', '51');
INSERT INTO `article_tag_ref` VALUES ('26', '43');
INSERT INTO `article_tag_ref` VALUES ('26', '50');
INSERT INTO `article_tag_ref` VALUES ('27', '48');
INSERT INTO `article_tag_ref` VALUES ('27', '49');
INSERT INTO `article_tag_ref` VALUES ('28', '43');
INSERT INTO `article_tag_ref` VALUES ('28', '47');
INSERT INTO `article_tag_ref` VALUES ('29', '46');
INSERT INTO `article_tag_ref` VALUES ('30', '42');
INSERT INTO `article_tag_ref` VALUES ('30', '45');
INSERT INTO `article_tag_ref` VALUES ('31', '43');
INSERT INTO `article_tag_ref` VALUES ('31', '46');
INSERT INTO `article_tag_ref` VALUES ('32', '1');
INSERT INTO `article_tag_ref` VALUES ('32', '12');
INSERT INTO `article_tag_ref` VALUES ('33', '9');
INSERT INTO `article_tag_ref` VALUES ('33', '10');
INSERT INTO `article_tag_ref` VALUES ('34', '10');
INSERT INTO `article_tag_ref` VALUES ('34', '42');
INSERT INTO `article_tag_ref` VALUES ('34', '43');
INSERT INTO `article_tag_ref` VALUES ('113', '45');
INSERT INTO `article_tag_ref` VALUES ('114', '1');
INSERT INTO `article_tag_ref` VALUES ('114', '42');
INSERT INTO `article_tag_ref` VALUES ('114', '43');
INSERT INTO `article_tag_ref` VALUES ('126', '40');
INSERT INTO `article_tag_ref` VALUES ('126', '41');
INSERT INTO `article_tag_ref` VALUES ('126', '42');
INSERT INTO `article_tag_ref` VALUES ('128', '1');
INSERT INTO `article_tag_ref` VALUES ('128', '2');
INSERT INTO `article_tag_ref` VALUES ('128', '3');
INSERT INTO `article_tag_ref` VALUES ('128', '16');
INSERT INTO `article_tag_ref` VALUES ('129', '1');
INSERT INTO `article_tag_ref` VALUES ('129', '2');
INSERT INTO `article_tag_ref` VALUES ('130', '1');
INSERT INTO `article_tag_ref` VALUES ('130', '6');
INSERT INTO `article_tag_ref` VALUES ('130', '20');
INSERT INTO `article_tag_ref` VALUES ('131', '40');
INSERT INTO `article_tag_ref` VALUES ('131', '41');
INSERT INTO `article_tag_ref` VALUES ('131', '42');

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `category_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `category_pid` int(11) DEFAULT '0',
  `category_name` varchar(50) DEFAULT NULL,
  `category_description` varchar(255) DEFAULT NULL,
  `category_order` int(11) unsigned DEFAULT '1',
  `category_icon` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`category_id`),
  UNIQUE KEY `category_name` (`category_name`)
) ENGINE=InnoDB AUTO_INCREMENT=64 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '0', 'Java', 'Java语言', '1', 'fa fa-coffee');
INSERT INTO `category` VALUES ('2', '1', 'Java基础', 'Java相关分类', '2', '');
INSERT INTO `category` VALUES ('3', '1', 'Core Java', 'Java核心', '1', '');
INSERT INTO `category` VALUES ('4', '1', '多线程并发编程', '多线程以及并发相关', '1', '');
INSERT INTO `category` VALUES ('5', '1', 'Sockets和IO', 'Socket流相关', '1', '');
INSERT INTO `category` VALUES ('7', '1', 'JVM', '虚拟机相关', '1', '');
INSERT INTO `category` VALUES ('8', '1', 'JavaWeb', 'Java网页相关', '1', '');
INSERT INTO `category` VALUES ('9', '1', 'Java框架', '', '1', '');
INSERT INTO `category` VALUES ('10', '0', '计算机科学', '计算机科学父目录', '1', 'fa fa-cubes');
INSERT INTO `category` VALUES ('12', '10', '操作系统', '操作系统', '1', '');
INSERT INTO `category` VALUES ('13', '10', '数据库', '', '1', '');
INSERT INTO `category` VALUES ('14', '10', '计算机网络', '', '1', '');
INSERT INTO `category` VALUES ('15', '0', '其他技术', '', '1', 'fa-snowflake-o fa');
INSERT INTO `category` VALUES ('16', '15', '消息服务', '', '1', '');
INSERT INTO `category` VALUES ('53', '1', '设计模式和反射', '计算机的设计模式以及反射模式', null, null);
INSERT INTO `category` VALUES ('54', '0', '笔记', '记录个人笔记相关的', '1', null);
INSERT INTO `category` VALUES ('55', '0', '前端', '前端的一些', '1', null);
INSERT INTO `category` VALUES ('56', '0', 'Linux', 'linux相关的', '1', null);
INSERT INTO `category` VALUES ('57', '0', 'vpn服务器', '用来介绍vpn相关的服务器', '1', null);
INSERT INTO `category` VALUES ('58', '57', 'vltur', 'vltur服务器', null, null);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `comment_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `comment_pid` int(11) unsigned DEFAULT '0',
  `comment_pname` varchar(255) DEFAULT NULL,
  `comment_article_id` int(11) unsigned DEFAULT NULL,
  `comment_author_name` varchar(50) DEFAULT NULL,
  `comment_author_email` varchar(50) DEFAULT NULL,
  `comment_like_count` int(11) DEFAULT '0',
  `comment_avatar_path` varchar(100) DEFAULT NULL,
  `comment_content` varchar(1000) DEFAULT NULL,
  `comment_ip` varchar(50) DEFAULT NULL,
  `comment_create_time` datetime DEFAULT NULL,
  `comment_role` int(1) DEFAULT NULL,
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=154 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('138', null, null, '130', '刘二傻子', '123@qq.com', '0', '\\static\\pic\\comment\\1555436158002.jpg', '我来评论啦', '0:0:0:0:0:0:0:1', '2019-04-17 01:35:58', '0');
INSERT INTO `comment` VALUES ('139', '138', '刘二傻子', '130', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '你在说什么东西', '0:0:0:0:0:0:0:1', '2019-04-17 01:40:27', '1');
INSERT INTO `comment` VALUES ('140', null, null, '129', 'Since', '331@qq.com', '0', '\\static\\pic\\comment\\default.jpg', '继续测试评论', '0:0:0:0:0:0:0:1', '2019-04-17 11:38:11', '0');
INSERT INTO `comment` VALUES ('141', null, null, '129', 'Never', '331@qq.com', '0', '\\static\\pic\\comment\\1555472311272.jpg', '还是要评论', '0:0:0:0:0:0:0:1', '2019-04-17 11:38:31', '0');
INSERT INTO `comment` VALUES ('142', null, null, '131', '小明', '654@qq.com', '0', '\\static\\pic\\comment\\default.jpg', '没有评论也要测试', '0:0:0:0:0:0:0:1', '2019-04-17 11:39:11', '0');
INSERT INTO `comment` VALUES ('143', null, null, '131', '小李啊', '654@qq.com', '0', '\\static\\pic\\comment\\1555472367725.jpg', '再来一次', '0:0:0:0:0:0:0:1', '2019-04-17 11:39:28', '0');
INSERT INTO `comment` VALUES ('144', null, null, '131', '小吴啊', '654@qq.com', '0', '\\static\\pic\\comment\\1555472382788.jpg', '而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看', '0:0:0:0:0:0:0:1', '2019-04-17 11:39:43', '0');
INSERT INTO `comment` VALUES ('145', null, null, '131', '小吴啊', '654@qq.com', '0', '\\static\\pic\\comment\\1555472392507.jpg', '为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢', '0:0:0:0:0:0:0:1', '2019-04-17 11:39:53', '0');
INSERT INTO `comment` VALUES ('146', null, null, '131', '小李', '654@qq.com', '0', '\\static\\pic\\comment\\1555472420355.jpg', 'Hi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。', '0:0:0:0:0:0:0:1', '2019-04-17 11:40:20', '0');
INSERT INTO `comment` VALUES ('147', null, null, '131', '太子', '654@qq.com', '0', '\\static\\pic\\comment\\1555472443595.jpg', '在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影', '0:0:0:0:0:0:0:1', '2019-04-17 11:40:44', '0');
INSERT INTO `comment` VALUES ('148', '147', '太子', '131', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '还没感谢！！！', '0:0:0:0:0:0:0:1', '2019-04-17 11:41:15', '1');
INSERT INTO `comment` VALUES ('149', '146', '小李', '131', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '还不知道', '0:0:0:0:0:0:0:1', '2019-04-17 11:41:23', '1');
INSERT INTO `comment` VALUES ('150', '143', '小李啊', '131', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '多谢了啊', '0:0:0:0:0:0:0:1', '2019-04-17 11:42:11', '1');
INSERT INTO `comment` VALUES ('151', '140', 'Since', '129', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '不需要知道其中的道理', '0:0:0:0:0:0:0:1', '2019-04-17 11:42:29', '1');
INSERT INTO `comment` VALUES ('152', '140', 'Since', '129', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', '我也很想知道啊', '0:0:0:0:0:0:0:1', '2019-04-17 11:42:39', '1');
INSERT INTO `comment` VALUES ('153', '138', '刘二傻子', '130', '刘宇东', null, '0', '\\static\\pic\\comment\\default.jpg', 'aaaaa', '0:0:0:0:0:0:0:1', '2019-04-17 15:32:19', '1');

-- ----------------------------
-- Table structure for log
-- ----------------------------
DROP TABLE IF EXISTS `log`;
CREATE TABLE `log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `time` datetime DEFAULT NULL COMMENT '操作时间',
  `type` varchar(255) DEFAULT NULL COMMENT '操作类型',
  `detail` varchar(255) DEFAULT NULL COMMENT '详情',
  `ip` varchar(255) DEFAULT NULL COMMENT 'ip',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=411 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of log
-- ----------------------------
INSERT INTO `log` VALUES ('6', '2017-10-20 22:49:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('7', '2017-10-20 22:55:40', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('8', '2017-10-20 22:55:50', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('9', '2017-10-20 22:55:59', '修改', '修改密码', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('10', '2017-10-20 23:09:25', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('11', '2017-10-20 23:10:36', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('12', '2017-10-20 23:12:04', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('13', '2017-10-20 23:13:45', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('14', '2017-10-20 23:46:28', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('15', '2017-10-21 00:12:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('16', '2017-10-21 00:13:04', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('17', '2017-10-21 00:32:49', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('18', '2017-10-21 00:35:40', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('19', '2017-10-21 00:40:22', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('20', '2017-10-21 00:40:25', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('21', '2017-10-21 00:40:56', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('22', '2017-10-21 00:41:30', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('23', '2017-10-21 00:41:43', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('24', '2017-10-21 00:41:48', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('25', '2017-10-21 00:42:07', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('26', '2017-10-21 00:50:13', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('27', '2017-10-21 10:47:46', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('28', '2017-10-21 11:13:26', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('29', '2017-10-21 11:14:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('30', '2017-10-21 12:26:24', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('31', '2017-10-21 12:29:57', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('32', '2017-10-21 12:36:57', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('33', '2017-10-21 12:44:44', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('34', '2017-10-21 12:58:23', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('35', '2017-10-21 13:12:44', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('36', '2017-10-21 14:31:29', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('37', '2017-10-21 14:32:25', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('38', '2017-10-21 15:02:40', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('39', '2017-10-21 15:20:55', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('40', '2017-10-21 15:28:58', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('41', '2017-10-21 16:06:43', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('42', '2017-10-21 16:29:58', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('43', '2017-10-21 16:51:31', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('44', '2017-10-21 17:02:39', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('45', '2017-10-21 17:03:07', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('46', '2017-10-21 17:05:53', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('47', '2017-10-21 17:05:59', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('48', '2017-10-21 17:06:09', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('49', '2017-10-21 17:10:27', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('50', '2017-10-21 17:10:32', '修改', '修改资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('51', '2017-10-21 17:10:43', '修改', '修改密码', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('52', '2017-10-21 17:10:54', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('53', '2017-10-21 17:11:04', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('54', '2017-10-21 17:14:24', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('55', '2017-10-21 17:15:25', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('56', '2017-10-21 17:16:04', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('57', '2017-10-21 17:18:16', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('58', '2017-10-21 17:18:23', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('59', '2017-10-21 17:18:29', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('60', '2017-10-21 17:18:48', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('61', '2017-10-21 17:18:58', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('62', '2017-10-21 17:20:55', '修改', '修改密码', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('63', '2017-10-21 17:26:54', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('64', '2017-10-21 17:27:10', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('65', '2017-10-21 17:27:18', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('66', '2017-10-21 17:27:34', '修改', '修改密码', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('67', '2017-10-21 17:28:23', '修改', '修改密码', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('68', '2017-10-21 17:29:26', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('69', '2017-10-21 17:35:58', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('70', '2017-10-21 17:37:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('71', '2017-10-21 17:40:11', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('72', '2017-10-21 22:04:14', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('73', '2017-10-21 22:12:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('74', '2017-10-21 23:25:19', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('75', '2017-10-21 23:25:31', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('76', '2017-10-21 23:36:03', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('77', '2017-10-21 23:36:55', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('78', '2017-10-21 23:45:39', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('79', '2017-10-21 23:55:10', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('80', '2017-10-21 23:56:06', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('81', '2017-10-21 23:56:16', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('82', '2017-10-21 23:59:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('83', '2017-10-22 00:00:03', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('86', '2017-10-22 00:01:28', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('87', '2017-10-22 00:07:33', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('88', '2017-10-22 00:09:13', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('89', '2017-10-22 00:10:44', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('90', '2017-10-22 00:11:41', '登陆', '用户登录', '192.168.1.104');
INSERT INTO `log` VALUES ('91', '2017-10-22 00:22:58', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('92', '2017-10-22 12:03:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('93', '2017-10-22 12:04:18', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('94', '2017-10-22 12:45:13', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('95', '2017-10-22 13:13:16', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('98', '2017-10-22 13:48:00', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('99', '2017-10-22 13:48:59', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('100', '2017-10-22 13:49:34', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('101', '2017-10-22 15:04:38', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('102', '2017-10-22 16:28:36', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('103', '2017-10-22 17:19:12', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('104', '2017-10-22 17:24:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('105', '2017-10-22 18:00:27', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('107', '2017-10-22 22:17:58', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('108', '2017-10-23 12:37:29', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('109', '2017-10-23 12:38:11', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('110', '2017-10-23 12:54:42', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('111', '2017-10-23 12:56:35', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('112', '2017-10-23 15:41:13', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('113', '2017-10-23 15:41:27', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('114', '2017-10-23 16:14:45', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('115', '2017-10-23 16:15:10', '登陆', '用户登录', '192.168.1.106');
INSERT INTO `log` VALUES ('116', '2017-10-23 16:16:28', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('117', '2017-10-23 16:17:33', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('118', '2017-10-23 16:17:34', '登陆', '用户登录', '192.168.1.106');
INSERT INTO `log` VALUES ('119', '2017-10-23 16:29:10', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('120', '2017-10-23 17:19:52', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('121', '2017-10-23 17:47:10', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('122', '2017-10-23 17:47:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('123', '2017-10-23 21:54:38', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('124', '2017-10-23 21:55:06', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('125', '2017-10-23 22:17:35', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('126', '2017-10-23 22:18:21', '登陆', '用户登录', '192.168.1.106');
INSERT INTO `log` VALUES ('128', '2017-10-23 23:16:19', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('129', '2017-10-23 23:16:21', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('130', '2017-10-23 23:17:39', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('131', '2017-10-23 23:17:42', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('132', '2017-10-23 23:19:23', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('133', '2017-10-23 23:19:26', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('134', '2017-10-23 23:23:24', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('135', '2017-10-23 23:23:35', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('136', '2017-10-23 23:24:04', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('137', '2017-10-23 23:29:25', '登陆', '用户登录', '192.168.1.108');
INSERT INTO `log` VALUES ('138', '2017-10-23 23:29:29', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('139', '2017-10-24 10:01:09', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('140', '2017-10-24 10:26:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('141', '2017-10-24 10:30:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('142', '2017-10-24 11:29:08', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('143', '2017-10-24 12:38:03', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('144', '2017-10-24 12:38:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('145', '2017-10-24 12:39:05', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('146', '2017-10-24 12:39:14', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('147', '2017-10-24 12:49:41', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('148', '2017-10-24 15:55:32', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('149', '2017-10-24 15:56:00', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('150', '2017-10-24 16:41:49', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('151', '2017-10-24 16:54:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('152', '2017-10-24 16:58:34', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('153', '2017-10-24 17:35:48', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('154', '2017-10-24 17:40:06', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('155', '2017-10-24 20:03:47', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('156', '2017-10-24 20:04:13', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('157', '2017-10-24 20:05:10', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('158', '2017-10-24 20:05:23', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('159', '2017-10-24 20:31:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('160', '2017-10-24 20:53:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('161', '2017-10-24 20:57:54', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('162', '2017-10-24 21:15:18', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('163', '2017-10-24 21:15:23', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('164', '2017-10-24 21:42:33', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('165', '2017-10-24 22:46:49', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('166', '2017-10-25 08:40:34', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('167', '2017-10-25 08:40:47', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('168', '2017-10-25 08:41:11', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('169', '2017-10-25 08:45:42', '登陆', '用户登录', '192.168.43.2');
INSERT INTO `log` VALUES ('170', '2017-10-25 13:18:11', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('171', '2017-10-25 13:18:24', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('172', '2017-10-25 13:20:17', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('173', '2017-10-25 13:24:13', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('174', '2017-10-25 13:24:19', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('175', '2017-10-25 13:24:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('176', '2017-10-25 14:28:45', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('177', '2017-10-25 15:08:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('178', '2017-10-25 15:15:26', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('179', '2017-10-25 15:44:30', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('180', '2017-10-25 15:54:59', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('181', '2017-10-25 16:51:59', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('182', '2017-10-25 16:57:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('183', '2017-10-25 16:57:43', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('184', '2017-10-25 16:57:58', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('188', '2017-10-25 19:53:02', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('189', '2017-10-25 19:58:28', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('190', '2017-10-25 19:59:50', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('191', '2017-10-25 20:02:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('192', '2017-10-25 21:25:16', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('193', '2017-10-25 21:25:31', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('194', '2017-10-25 21:26:15', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('195', '2017-10-25 22:14:03', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('196', '2017-10-25 22:16:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('197', '2017-10-25 22:17:21', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('198', '2017-10-26 16:26:54', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('199', '2017-10-26 16:27:16', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('200', '2017-10-26 16:31:23', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('201', '2017-11-22 13:34:08', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('202', '2017-11-22 13:34:37', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('203', '2017-11-22 13:36:00', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('206', '2017-11-22 15:52:27', '��½', '�û���¼', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('208', '2017-11-22 15:53:19', '�޸�', '�޸�ͷ��', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('209', '2017-11-22 15:58:14', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('210', '2017-11-22 16:04:29', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('211', '2017-11-22 16:05:03', '登陆', '用户登录', '127.0.0.1');
INSERT INTO `log` VALUES ('212', '2017-11-22 16:05:50', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('213', '2017-11-22 18:29:44', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('214', '2017-11-22 18:33:52', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('215', '2017-11-22 19:29:36', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('216', '2017-11-22 20:04:46', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('217', '2017-11-22 20:11:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('218', '2017-11-22 20:14:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('219', '2017-11-22 20:18:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('220', '2017-11-22 20:20:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('221', '2017-11-22 20:21:10', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('222', '2017-11-22 20:23:03', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('223', '2017-11-22 20:25:53', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('224', '2017-11-22 20:27:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('225', '2017-11-22 20:27:59', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('226', '2017-11-22 20:28:09', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('227', '2017-11-22 20:31:24', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('228', '2017-11-22 20:31:42', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('229', '2017-12-20 11:56:20', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('230', '2017-12-20 11:57:06', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('231', '2017-12-20 11:57:56', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('232', '2017-12-22 17:40:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('233', '2017-12-22 19:33:49', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('234', '2017-12-24 01:31:51', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('235', '2017-12-26 00:09:06', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('236', '2017-12-26 00:09:56', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('237', '2017-12-26 00:11:14', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('238', '2017-12-26 00:12:50', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('239', '2017-12-26 00:13:04', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('240', '2018-07-08 15:20:35', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('241', '2018-09-19 08:09:34', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('242', '2018-09-19 08:10:25', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('243', '2018-09-19 08:11:50', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('244', '2018-11-19 19:06:12', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('245', '2018-11-19 19:06:41', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('246', '2018-11-19 19:17:32', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('247', '2018-11-19 19:18:22', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('248', '2019-01-22 15:21:36', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('249', '2019-01-22 15:22:10', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('250', '2019-01-22 15:25:25', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('251', '2019-01-22 15:32:39', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('252', '2019-04-02 00:54:02', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('253', '2019-04-02 00:54:21', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('254', '2019-04-02 01:55:27', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('255', '2019-04-02 01:55:38', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('256', '2019-04-02 02:04:38', '登陆', '用户登录', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('257', '2019-04-02 02:04:52', '修改', '修改头像', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('258', null, null, '111', null);
INSERT INTO `log` VALUES ('259', '2019-04-15 01:50:10', null, '111', null);
INSERT INTO `log` VALUES ('261', '2019-04-15 13:15:15', '添加', '亲亲钱', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('262', '2019-04-15 13:23:44', '添加', '全球啊啊啊我', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('263', '2019-04-15 13:23:44', '添加', '啊啊啊啊啊啊啊啊啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('264', '2019-04-15 13:30:18', '添加博客', '威威威威威威威威威威', '');
INSERT INTO `log` VALUES ('265', '2019-04-15 13:32:12', '添加博客', '亲亲亲亲亲亲我我', '');
INSERT INTO `log` VALUES ('266', '2019-04-15 13:35:27', '添加博客', '强强犬瘟热', '');
INSERT INTO `log` VALUES ('267', '2019-04-15 13:38:10', '添加博客', '23232', '');
INSERT INTO `log` VALUES ('268', '2019-04-15 13:38:28', '添加博客', '啊啊啊的', '');
INSERT INTO `log` VALUES ('269', '2019-04-15 13:46:50', '添加博客', '五五七二五七', '');
INSERT INTO `log` VALUES ('270', '2019-04-15 13:47:11', '修改博客', '五五七二五七亲亲亲亲', '');
INSERT INTO `log` VALUES ('271', '2019-04-15 13:47:49', '添加博客', '啊啊啊啊啊试试', '');
INSERT INTO `log` VALUES ('272', '2019-04-15 13:48:02', '修改博客', '啊啊啊啊啊试试无为而无', '');
INSERT INTO `log` VALUES ('277', '2019-04-15 13:58:30', '删除分类', '全请问去', '');
INSERT INTO `log` VALUES ('278', '2019-04-15 14:11:52', '添加标签', '啊啊啊', '');
INSERT INTO `log` VALUES ('279', '2019-04-15 14:12:25', '添加标签', '啊啊啊', '');
INSERT INTO `log` VALUES ('280', '2019-04-15 14:12:55', '修改标签', 'Socket1', '');
INSERT INTO `log` VALUES ('281', '2019-04-15 14:13:42', '修改标签', 'Socket', '');
INSERT INTO `log` VALUES ('282', '2019-04-15 14:13:58', '有人评论', '啊啊啊', '');
INSERT INTO `log` VALUES ('284', '2019-04-15 14:18:35', '删除评论', 'QAQ', '');
INSERT INTO `log` VALUES ('287', '2019-04-15 14:29:37', '修改博客', '五五七二五七亲亲亲亲', '阿达');
INSERT INTO `log` VALUES ('288', '2019-04-15 16:08:12', '删除博客', '五五七二五七亲亲亲亲', '');
INSERT INTO `log` VALUES ('289', '2019-04-15 16:08:17', '删除博客', '绕太阳', '');
INSERT INTO `log` VALUES ('290', '2019-04-15 16:11:10', '删除博客', 'w\'w\'we哇哇哇哇', '');
INSERT INTO `log` VALUES ('291', '2019-04-15 16:11:22', '删除博客', '啊啊啊的', '');
INSERT INTO `log` VALUES ('292', '2019-04-15 16:12:12', '删除博客', '23232', '');
INSERT INTO `log` VALUES ('293', '2019-04-15 19:17:25', '删除博客', '啊啊啊a', '');
INSERT INTO `log` VALUES ('294', '2019-04-15 19:17:28', '删除博客', '亲亲钱', '');
INSERT INTO `log` VALUES ('295', '2019-04-15 19:17:30', '删除博客', '全球啊啊啊我', '');
INSERT INTO `log` VALUES ('296', '2019-04-15 19:17:32', '删除博客', '啊啊啊啊啊啊啊啊啊啊', '');
INSERT INTO `log` VALUES ('297', '2019-04-15 19:17:34', '删除博客', '威威威威威威威威威威', '');
INSERT INTO `log` VALUES ('298', '2019-04-15 19:17:36', '删除博客', '亲亲亲亲亲亲我我', '');
INSERT INTO `log` VALUES ('299', '2019-04-15 19:17:39', '删除博客', '强强犬瘟热', '');
INSERT INTO `log` VALUES ('300', '2019-04-15 23:15:51', '修改密码', '1234', '');
INSERT INTO `log` VALUES ('301', '2019-04-15 23:41:50', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('302', '2019-04-16 00:00:32', '修改密码', '123', '');
INSERT INTO `log` VALUES ('303', '2019-04-16 00:54:19', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('304', '2019-04-16 01:10:26', '修改博客', '一周一部好电影V【WEEK210 网络迷踪】', '');
INSERT INTO `log` VALUES ('305', '2019-04-16 01:10:40', '修改博客', '一周一部好电影V【WEEK210 网络迷踪】', '');
INSERT INTO `log` VALUES ('306', '2019-04-16 01:10:49', '修改博客', 'Electron-vue开发实战6——开发插件系统之GUI部分', '');
INSERT INTO `log` VALUES ('307', '2019-04-16 01:11:06', '删除标签', 'MySQL', '');
INSERT INTO `log` VALUES ('308', '2019-04-16 01:11:33', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('309', '2019-04-16 13:09:28', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('310', '2019-04-16 13:11:16', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('311', '2019-04-16 13:11:50', '修改', '修改了个人资料', '');
INSERT INTO `log` VALUES ('312', '2019-04-16 13:25:08', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('313', '2019-04-16 13:26:12', '回复评论', '你咋知道的', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('314', '2019-04-16 13:29:18', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('315', '2019-04-16 13:40:33', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('316', '2019-04-16 13:50:57', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('317', '2019-04-16 13:51:02', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('318', '2019-04-16 13:51:58', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('319', '2019-04-16 13:52:03', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('320', '2019-04-16 13:52:32', '添加博客', '哈哈哈哈哈', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('321', '2019-04-16 13:53:29', '删除博客', '哈哈哈哈哈', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('322', '2019-04-16 13:54:57', '添加博客', '请问强', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('323', '2019-04-16 13:56:01', '修改博客', 'jQuery——删除 动态添加的元素的方法', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('324', '2019-04-16 13:56:41', '修改博客', 'jQuery——删除 动态添加的元素的方法', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('325', '2019-04-16 14:01:38', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('326', '2019-04-16 14:01:50', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('327', '2019-04-16 14:02:27', '删除博客', '请问强', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('328', '2019-04-16 14:06:13', '修改博客', 'jQuery——删除 动态添加的元素的方法', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('329', '2019-04-16 14:10:39', '退出', '退出登陆', '');
INSERT INTO `log` VALUES ('330', '2019-04-16 14:10:46', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('331', '2019-04-16 14:11:03', '修改博客', '把你的github操作从ssh转成https', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('332', '2019-04-16 14:11:25', '修改博客', '把你的github操作从ssh转成https', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('333', '2019-04-16 14:12:34', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('334', '2019-04-16 14:12:38', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('335', '2019-04-16 14:13:06', '添加博客', '你都知道了啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('336', '2019-04-16 14:13:30', '删除博客', '你都知道了啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('337', '2019-04-16 14:13:56', '删除分类', '啊啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('338', '2019-04-16 14:14:39', '修改标签', 'Socket1', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('339', '2019-04-16 14:14:59', '修改标签', 'Socket', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('340', '2019-04-16 14:15:16', '删除标签', '多线程', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('341', '2019-04-16 14:16:06', '修改', '修改了个人资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('342', '2019-04-16 14:23:26', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('343', '2019-04-16 22:33:31', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('344', '2019-04-16 22:34:05', '添加博客', '不知道填写什么啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('345', '2019-04-16 22:38:10', '删除博客', '不知道填写什么啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('346', '2019-04-16 22:55:19', '添加博客', '不知道填写什么啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('347', '2019-04-16 22:56:45', '修改博客', '还能写什么', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('348', '2019-04-16 22:57:39', '修改博客', '还能写什你说呢', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('349', '2019-04-16 22:58:03', '删除博客', '还能写什你说呢', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('350', '2019-04-16 22:58:43', '删除博客', '啊啊啊啊啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('351', '2019-04-16 22:58:58', '删除博客', '啊啊啊啊啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('352', '2019-04-16 23:02:30', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('353', '2019-04-16 23:02:50', '添加博客', '开发的是的啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('354', '2019-04-16 23:03:18', '修改博客', '怎么可能是的呢', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('355', '2019-04-16 23:03:37', '删除博客', '怎么可能是的呢', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('356', '2019-04-16 23:52:08', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('357', '2019-04-17 00:10:32', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('358', '2019-04-17 01:38:21', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('359', '2019-04-17 01:38:26', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('360', '2019-04-17 01:38:31', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('361', '2019-04-17 01:38:57', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('362', '2019-04-17 01:39:28', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('363', '2019-04-17 01:40:07', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('364', '2019-04-17 01:40:10', '退出', '退出登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('365', '2019-04-17 01:40:14', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('366', '2019-04-17 01:40:27', '回复评论', '你在说杀什么啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('367', '2019-04-17 01:41:10', '修改我的回复', '你在说什么东西', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('368', '2019-04-17 11:36:05', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('369', '2019-04-17 11:41:15', '回复评论', '还没感谢！！！', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('370', '2019-04-17 11:41:23', '回复评论', '还不知道', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('371', '2019-04-17 11:42:11', '回复评论', '多谢了啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('372', '2019-04-17 11:42:29', '回复评论', '不需要知道其中的道理', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('373', '2019-04-17 11:42:39', '回复评论', '我也很想知道啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('374', '2019-04-17 11:42:44', '修改我的回复', '我也很想知道啊1', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('375', '2019-04-17 11:47:10', '添加标签', '啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('376', '2019-04-17 13:00:51', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('377', '2019-04-17 13:01:44', '添加分类', '122', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('378', '2019-04-17 13:01:56', '修改分类', '1223', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('379', '2019-04-17 13:02:21', '删除分类', '1223', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('380', '2019-04-17 13:03:55', '添加标签', '啊啊啊', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('381', '2019-04-17 13:25:09', '修改', '修改了个人资料', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('382', '2019-04-17 14:19:43', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('383', '2019-04-17 15:29:05', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('384', '2019-04-17 15:32:19', '回复评论', 'aaaaa', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('386', '2019-04-17 15:42:25', '修改我的回复', 'aaaaa12', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('387', '2019-04-17 15:44:40', '修改我的回复', 'aaaaa123', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('390', '2019-04-17 15:47:28', '修改我的回复', 'aaaaa123a12', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('395', '2019-04-17 16:22:50', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('396', '2019-04-17 16:31:28', '修改', '修改页面背景图', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('397', '2019-04-17 17:01:42', '修改博客', '把你的github操作从ssh转成https', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('398', '2019-04-17 17:11:54', '修改分类', 'Java基础', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('399', '2019-04-17 17:42:33', '登陆', '用户登陆', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('400', '2019-04-17 17:42:59', '添加博客', '哈哈哈哈', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('401', '2019-04-17 17:43:18', '删除博客', '哈哈哈哈', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('402', '2019-04-17 17:50:21', '修改分类', 'Java基础', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('403', '2019-04-17 17:50:33', '修改分类', 'Core Java', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('404', '2019-04-17 17:50:50', '修改分类', '多线程并发编程', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('405', '2019-04-17 17:51:03', '修改分类', 'Sockets和IO', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('406', '2019-04-17 17:51:14', '修改分类', 'JVM', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('407', '2019-04-17 17:51:33', '修改分类', 'JavaWeb', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('408', '2019-04-17 17:51:43', '修改分类', '计算机科学', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('409', '2019-04-17 17:51:51', '修改分类', '操作系统', '0:0:0:0:0:0:0:1');
INSERT INTO `log` VALUES ('410', '2019-04-17 17:54:33', '退出', '退出登陆', '0:0:0:0:0:0:0:1');

-- ----------------------------
-- Table structure for page
-- ----------------------------
DROP TABLE IF EXISTS `page`;
CREATE TABLE `page` (
  `page_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `page_flag` int(11) DEFAULT NULL,
  `page_tag` varchar(255) DEFAULT NULL,
  `image_path` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`page_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of page
-- ----------------------------
INSERT INTO `page` VALUES ('1', '1', 'Carrying my full memory, you\'re far away', 'static/images/1555489887530.jpg');
INSERT INTO `page` VALUES ('2', '2', 'Nothing is impossible to a willing heart', 'static/images/1555489420622.jpg');
INSERT INTO `page` VALUES ('3', '3', 'Pursue your object, be it what it will, steadily and indefatigably', 'static/images/1555347781104.jpg');
INSERT INTO `page` VALUES ('4', '4', 'Carrying my full memory, you\'re far away', 'static/images/1555347787279.jpg');
INSERT INTO `page` VALUES ('5', '5', 'To watch the sunrise must wait till dawn', 'static/images/1555347790324.jpg');
INSERT INTO `page` VALUES ('6', '6', 'Determined to not firm, with nothing', 'static/images/1555347796536.jpg');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `tag_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) DEFAULT NULL,
  `font_size` varchar(255) DEFAULT '20px',
  `font_color` varchar(255) DEFAULT '#49b1f5',
  PRIMARY KEY (`tag_id`),
  UNIQUE KEY `tag_name` (`tag_name`)
) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('1', 'Java', '20px', '#49b1f5');
INSERT INTO `tag` VALUES ('2', '算法', '39px', '#00b1f5');
INSERT INTO `tag` VALUES ('3', '数据结构', '40px', '#FFC1C1');
INSERT INTO `tag` VALUES ('5', '操作系统', '20px', '#93ece1');
INSERT INTO `tag` VALUES ('6', '计算机网络', '25px', '#2520df');
INSERT INTO `tag` VALUES ('8', '面试题', '32px', '#00b3f1');
INSERT INTO `tag` VALUES ('9', '数据库', null, null);
INSERT INTO `tag` VALUES ('10', 'MySQL', null, null);
INSERT INTO `tag` VALUES ('11', 'Spring', '30px', '#35f21c');
INSERT INTO `tag` VALUES ('12', 'SpringMVC', null, null);
INSERT INTO `tag` VALUES ('13', 'MyBatis', null, null);
INSERT INTO `tag` VALUES ('14', 'JVM', null, null);
INSERT INTO `tag` VALUES ('15', '设计模式', null, null);
INSERT INTO `tag` VALUES ('16', '网络编程', null, null);
INSERT INTO `tag` VALUES ('17', 'IO', null, null);
INSERT INTO `tag` VALUES ('18', 'JSP', null, null);
INSERT INTO `tag` VALUES ('19', 'Servlet', null, null);
INSERT INTO `tag` VALUES ('20', 'JavaWeb', null, null);
INSERT INTO `tag` VALUES ('21', 'Hibernate', null, null);
INSERT INTO `tag` VALUES ('22', 'SQL', null, null);
INSERT INTO `tag` VALUES ('24', 'Redis', null, null);
INSERT INTO `tag` VALUES ('25', 'SPA', null, null);
INSERT INTO `tag` VALUES ('26', 'SpringCloud', null, null);
INSERT INTO `tag` VALUES ('28', 'EDAS', '29px', '#25cf12');
INSERT INTO `tag` VALUES ('29', 'MongoDB', null, null);
INSERT INTO `tag` VALUES ('31', 'SpringBoot', null, null);
INSERT INTO `tag` VALUES ('32', 'ElasticSearch', null, null);
INSERT INTO `tag` VALUES ('34', 'Jenkins', '52px', '#3755e3');
INSERT INTO `tag` VALUES ('37', 'Shiro', '20px', '#87ea57');
INSERT INTO `tag` VALUES ('38', 'ssm', '20px', '#49b1f5');
INSERT INTO `tag` VALUES ('40', '电影推荐', '20px', '#2d9900');
INSERT INTO `tag` VALUES ('41', '电影', '30px', '#ff00ff');
INSERT INTO `tag` VALUES ('42', '闲杂', '30px', '#00b1f5');
INSERT INTO `tag` VALUES ('43', '其他', '20px', '#00b1f5');
INSERT INTO `tag` VALUES ('45', '前端', '23px', '#000080');
INSERT INTO `tag` VALUES ('46', 'Github', '20px', '#93fc03');
INSERT INTO `tag` VALUES ('47', 'Linux', '20px', '#26211e');
INSERT INTO `tag` VALUES ('48', 'vpn', '20px', '#26211e');
INSERT INTO `tag` VALUES ('49', '服务器', '26px', '#212b15');
INSERT INTO `tag` VALUES ('50', '正则表达式', '26px', '#212b15');
INSERT INTO `tag` VALUES ('51', '多线程', '30px', '#10538f');
INSERT INTO `tag` VALUES ('52', 'Socket', '30px', '#63301d');
INSERT INTO `tag` VALUES ('57', '啊啊', '20px', '#26211e');
INSERT INTO `tag` VALUES ('58', '啊啊啊', '20px', '#2c1414');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL DEFAULT '',
  `user_pass` varchar(255) NOT NULL DEFAULT '',
  `user_nickname` varchar(255) NOT NULL DEFAULT '',
  `page_nickname` varchar(100) DEFAULT '',
  `user_signature` varchar(500) DEFAULT NULL,
  `user_email` varchar(100) DEFAULT '',
  `avatar_path` varchar(255) DEFAULT NULL,
  `markdown_profile` text,
  `html_profile` text,
  `person_tag` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_name` (`user_name`),
  UNIQUE KEY `user_email` (`page_nickname`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'admin', '123', '刘宇东', 'SinceNovember', 'never put yourself on putifset', '83428190@qq.com', 'static/images/1555478709092.jpg', '# 关于自己\r\n![](/Blog/static/pic/1555349119482.jpg)\r\n本科在读，16年开始学习后端。\r\n来自江苏淮安。\r\n姓名：刘宇东\r\ngithub:[http://www.github,com/SinceNovember](http://www.github,com/SinceNovember)\r\n1. 用心做\r\n2. 用心做\r\n3. 用心做\r\n4. 用心做\r\n5. 用心做\r\n6. 用心做\r\n7. 用心做\r\n8. 用心做\r\n9. 用心做\r\n10. 用心做\r\n', '<h1 id=\"h1-u5173u4E8Eu81EAu5DF1\"><a name=\"关于自己\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于自己</h1><p><img src=\"/Blog/static/pic/1555349119482.jpg\" alt=\"\"><br>本科在读，16年开始学习后端。<br>来自江苏淮安。<br>姓名：刘宇东<br>github:<a href=\"http://www.github,com/SinceNovember\">http://www.github,com/SinceNovember</a></p>\r\n<ol>\r\n<li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li><li>用心做</li></ol>\r\n', '学生 SinceoNovember 设计 自己 开发 Java ppp');
